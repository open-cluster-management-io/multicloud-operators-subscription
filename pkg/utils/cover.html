
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aws: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/aws/objectstore.go (76.7%)</option>
				
				<option value="file1">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/cert.go (56.5%)</option>
				
				<option value="file2">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/eventlog.go (61.9%)</option>
				
				<option value="file3">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/git_test_helper.go (100.0%)</option>
				
				<option value="file4">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/gitrepo.go (56.3%)</option>
				
				<option value="file5">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/helmrepo.go (73.7%)</option>
				
				<option value="file6">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/kubernetes.go (75.0%)</option>
				
				<option value="file7">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/kustomize.go (53.5%)</option>
				
				<option value="file8">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/label.go (89.7%)</option>
				
				<option value="file9">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/override.go (45.7%)</option>
				
				<option value="file10">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/policyreport.go (67.6%)</option>
				
				<option value="file11">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/reference.go (21.4%)</option>
				
				<option value="file12">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/subscription.go (34.1%)</option>
				
				<option value="file13">open-cluster-management.io/multicloud-operators-subscription/pkg/utils/timewindow.go (93.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package aws

import (
        "bytes"
        "context"
        "io/ioutil"
        "strings"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "k8s.io/klog/v2"
)

// ObjectStore interface.
type ObjectStore interface {
        InitObjectStoreConnection(endpoint, accessKeyID, secretAccessKey, region string) error
        Exists(bucket string) error
        Create(bucket string) error
        List(bucket string, folderName *string) ([]string, error)
        Put(bucket string, dplObj DeployableObject) error
        Delete(bucket, name string) error
        Get(bucket, name string) (DeployableObject, error)
}

var _ ObjectStore = &amp;Handler{}

const (
        // SecretMapKeyAccessKeyID is key of accesskeyid in secret.
        SecretMapKeyAccessKeyID = "AccessKeyID"
        // SecretMapKeySecretAccessKey is key of secretaccesskey in secret.
        SecretMapKeySecretAccessKey = "SecretAccessKey"
        // SecretMapKeyRegion is key of region in secret.
        SecretMapKeyRegion = "Region"
        // metadata key for stroing the deployable generatename name.
        DeployableGenerateNameMeta = "x-amz-meta-generatename"
        // Deployable generate name key within the meta map.
        DployableMateGenerateNameKey = "Generatename"
        // metadata key for stroing the deployable generatename name.
        DeployableVersionMeta = "x-amz-meta-deployableversion"
        // Deployable generate name key within the meta map.
        DeployableMetaVersionKey = "Deployableversion"
)

// Handler handles connections to aws.
type Handler struct {
        *s3.Client
}

// credentialProvider provides credetials for mcm hub deployable.
type credentialProvider struct {
        Value aws.Credentials
}

// Retrieve follow the Provider interface.
func (p credentialProvider) Retrieve(ctx context.Context) (aws.Credentials, error) <span class="cov8" title="1">{
        awscred := aws.Credentials{
                SecretAccessKey: p.Value.SecretAccessKey,
                AccessKeyID:     p.Value.AccessKeyID,
        }

        return awscred, nil
}</span>

type DeployableObject struct {
        Name         string
        GenerateName string
        Version      string
        Content      []byte
}

func (d DeployableObject) isEmpty() bool <span class="cov8" title="1">{
        if d.Name == "" &amp;&amp; d.GenerateName == "" &amp;&amp; len(d.Content) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func isAwsS3ObjectBucket(endpoint string) bool <span class="cov8" title="1">{
        if strings.Contains(strings.ToLower(endpoint), strings.ToLower("s3://")) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if strings.Contains(strings.ToLower(endpoint), strings.ToLower("s3")) &amp;&amp;
                strings.Contains(strings.ToLower(endpoint), strings.ToLower("aws")) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// InitObjectStoreConnection connect to object store.
func (h *Handler) InitObjectStoreConnection(endpoint, accessKeyID, secretAccessKey, region string) error <span class="cov8" title="1">{
        klog.Infof("Preparing S3 settings endpoint: %v", endpoint)

        // set the default object store region  as minio
        objectRegion := "minio"

        if isAwsS3ObjectBucket(endpoint) </span><span class="cov0" title="0">{
                objectRegion = region
        }</span>

        // aws s3 object store doesn't need to specify URL.
        // minio object store needs immutable URL. The aws sdk is not allowed to modify the host name of the minio URL
        <span class="cov8" title="1">customResolver := aws.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov8" title="1">{
                klog.V(1).Infof("service: %v, region: %v", service, region)
                if region == "minio" </span><span class="cov8" title="1">{
                        return aws.Endpoint{
                                URL:               endpoint,
                                HostnameImmutable: true,
                        }, nil
                }</span>
                <span class="cov0" title="0">return aws.Endpoint{}, &amp;aws.EndpointNotFoundError{}</span>
        })

        <span class="cov8" title="1">cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithEndpointResolverWithOptions(customResolver))
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to load aws config. error: ", err)

                return err
        }</span>

        <span class="cov8" title="1">objCredential := credentialProvider{
                Value: aws.Credentials{
                        AccessKeyID:     accessKeyID,
                        SecretAccessKey: secretAccessKey,
                },
        }

        h.Client = s3.NewFromConfig(cfg, func(o *s3.Options) </span><span class="cov8" title="1">{
                o.Region = objectRegion
                o.Credentials = objCredential
        }</span>)

        <span class="cov8" title="1">if h.Client == nil </span><span class="cov0" title="0">{
                klog.Error("Failed to connect to s3 service")

                return err
        }</span>

        <span class="cov8" title="1">klog.V(1).Info("S3 configured ")

        return nil</span>
}

// Create a bucket.
func (h *Handler) Create(bucket string) error <span class="cov8" title="1">{
        resp, err := h.Client.CreateBucket(context.TODO(), &amp;s3.CreateBucketInput{
                Bucket: &amp;bucket,
        })
        if err != nil </span><span class="cov8" title="1">{
                klog.Error("Failed to create bucket ", bucket, ". error: ", err)

                return err
        }</span>

        <span class="cov8" title="1">klog.Infof("resp: %#v", resp)

        return nil</span>
}

// Exists Checks whether a bucket exists and is accessible.
func (h *Handler) Exists(bucket string) error <span class="cov8" title="1">{
        _, err := h.Client.HeadBucket(context.TODO(), &amp;s3.HeadBucketInput{
                Bucket: &amp;bucket,
        })

        if err != nil </span><span class="cov8" title="1">{
                klog.Error("Failed to access bucket ", bucket, ". error: ", err)

                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// List all objects in bucket.
func (h *Handler) List(bucket string, folderName *string) ([]string, error) <span class="cov8" title="1">{
        klog.V(1).Info("List S3 Objects ", bucket)

        if folderName != nil </span><span class="cov0" title="0">{
                tmpFolderName := *folderName
                if len(tmpFolderName) &gt; 0 &amp;&amp; tmpFolderName[len(tmpFolderName)-1:] != "/" </span><span class="cov0" title="0">{
                        tmpFolderName += "/"
                }</span>

                <span class="cov0" title="0">folderName = &amp;tmpFolderName</span>
        }

        <span class="cov8" title="1">params := &amp;s3.ListObjectsV2Input{
                Bucket: aws.String(bucket),
                Prefix: folderName,
        }

        paginator := s3.NewListObjectsV2Paginator(h.Client, params, func(o *s3.ListObjectsV2PaginatorOptions) </span><span class="cov8" title="1">{
                o.Limit = 1000
        }</span>)

        <span class="cov8" title="1">var keys []string

        var objErr error

        pageNum := 0

        for paginator.HasMorePages() </span><span class="cov8" title="1">{
                output, err := paginator.NextPage(context.TODO())
                if err != nil </span><span class="cov8" title="1">{
                        klog.Infof("Got error retrieving list of objects. err: %v", err)
                        objErr = err

                        break</span>
                }

                <span class="cov8" title="1">for _, value := range output.Contents </span><span class="cov0" title="0">{
                        key := *value.Key
                        if len(key) &gt; 0 &amp;&amp; key[len(key)-1:] != "/" </span><span class="cov0" title="0">{
                                keys = append(keys, *value.Key)
                        }</span> else<span class="cov0" title="0"> {
                                klog.V(1).Info("Skipping S3 Object: ", key)
                        }</span>
                }
                <span class="cov8" title="1">pageNum++</span>
        }

        <span class="cov8" title="1">klog.Infof("List S3 Objects result, page Num: %v, keys: %v, err: %v ", pageNum, keys, objErr)

        return keys, objErr</span>
}

// Get get existing object.
func (h *Handler) Get(bucket, name string) (DeployableObject, error) <span class="cov8" title="1">{
        dplObj := DeployableObject{}

        resp, err := h.Client.GetObject(context.TODO(), &amp;s3.GetObjectInput{
                Bucket: &amp;bucket,
                Key:    &amp;name,
        })
        if err != nil </span><span class="cov8" title="1">{
                klog.Error("Failed to send Get request. error: ", err)

                return dplObj, err
        }</span>

        <span class="cov8" title="1">generateName := resp.Metadata[DployableMateGenerateNameKey]
        version := resp.Metadata[DeployableMetaVersionKey]
        body, err := ioutil.ReadAll(resp.Body)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to parse Get request. error: ", err)

                return dplObj, err
        }</span>

        <span class="cov8" title="1">if len(body) == 0 </span><span class="cov0" title="0">{
                return DeployableObject{}, nil
        }</span>

        <span class="cov8" title="1">dplObj.Name = name
        dplObj.GenerateName = generateName
        dplObj.Content = body
        dplObj.Version = version

        klog.V(1).Info("Get Success: \n", string(body))

        return dplObj, nil</span>
}

// Put create new object.
func (h *Handler) Put(bucket string, dplObj DeployableObject) error <span class="cov8" title="1">{
        if dplObj.isEmpty() </span><span class="cov0" title="0">{
                klog.V(1).Infof("got an empty deployableObject to put to object store")

                return nil
        }</span>

        <span class="cov8" title="1">resp, err := h.Client.PutObject(context.TODO(), &amp;s3.PutObjectInput{
                Bucket: &amp;bucket,
                Key:    &amp;dplObj.Name,
                Body:   bytes.NewReader(dplObj.Content),
        })
        if err != nil </span><span class="cov8" title="1">{
                klog.Error("Failed to send Put request. error: ", err)

                return err
        }</span>

        <span class="cov8" title="1">klog.V(5).Info("Put Success", resp)

        return nil</span>
}

// Delete delete existing object.
func (h *Handler) Delete(bucket, name string) error <span class="cov8" title="1">{
        resp, err := h.Client.DeleteObject(context.TODO(), &amp;s3.DeleteObjectInput{
                Bucket: &amp;bucket,
                Key:    &amp;name,
        })
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to send Delete request. error: ", err)

                return err
        }</span>

        <span class="cov8" title="1">klog.V(1).Info("Delete Success", resp)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2020 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "math/big"
        "os"
        "path/filepath"
        "time"

        "k8s.io/klog/v2"
)

func GenerateServerCerts(dir string) error <span class="cov8" title="1">{
        var err error
        privateKey, err := rsa.GenerateKey(rand.Reader, 4096)

        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Failed to generate private key: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">notBefore := time.Now()
        notAfter := notBefore.AddDate(5, 0, 0)

        ca := x509.Certificate{
                SerialNumber: big.NewInt(2019),
                Subject: pkix.Name{
                        Organization: []string{"Red Hat, Inc."},
                        Country:      []string{"CA"},
                },
                NotBefore:             notBefore,
                NotAfter:              notAfter,
                IsCA:                  true,
                KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
        }

        caBytes, err := x509.CreateCertificate(rand.Reader, &amp;ca, &amp;ca, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Failed to create certificate: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                err = os.MkdirAll(dir, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err, "Failed to make directory ", dir)
                        return err
                }</span>
        }

        <span class="cov8" title="1">certFilePath := filepath.Join(dir, "tls.crt")
        certOut, err := os.Create(filepath.Clean(certFilePath))

        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Failed to open tls.crt for writing: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">if err := pem.Encode(certOut, &amp;pem.Block{Type: "CERTIFICATE", Bytes: caBytes}); err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Failed to write data to tls.crt: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">if err := certOut.Close(); err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Error closing tls.crt: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">klog.Infof("tls.crt file was generated successfully.\n")

        keyFilePath := filepath.Join(dir, "tls.key")
        keyOut, err := os.OpenFile(filepath.Clean(keyFilePath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)

        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Failed to open tls.key for writing: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">privBytes, err := x509.MarshalPKCS8PrivateKey(privateKey)

        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Unable to marshal private key: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">if err := pem.Encode(keyOut, &amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: privBytes}); err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Failed to write data to tls.key: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">if err := keyOut.Close(); err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Error closing tls.key: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">klog.Infof("tls.key file was generated successfully.\n")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "regexp"
        "runtime"

        corev1 "k8s.io/api/core/v1"
        apiruntime "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        typedcorev1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/record"
        "k8s.io/klog/v2"
)

// QuiteLogLel - "important" information
const QuiteLogLel = 4

// NoiseLogLel - information inside "important functions"
const NoiseLogLel = 5

// VeryNoisy = show call stack, routine  and everything
const VeryNoisy = 10

var regexStripFnPreamble = regexp.MustCompile(`^.*\.(.*)$`)

// GetFnName - get name of function
func GetFnName() string <span class="cov0" title="0">{
        fnName := "&lt;unknown&gt;"
        // Skip this function, and fetch the PC and file for its parent
        pc, _, _, ok := runtime.Caller(1)
        if ok </span><span class="cov0" title="0">{
                fnName = regexStripFnPreamble.ReplaceAllString(runtime.FuncForPC(pc).Name(), "$1")
        }</span>

        <span class="cov0" title="0">return fnName</span>
}

// EnterFnString - called when enter a function
func EnterFnString() string <span class="cov0" title="0">{
        return ""
}</span>

// ExitFuString - called when exiting a function
func ExitFuString(s string) {<span class="cov0" title="0">}</span>

// EventRecorder - record kubernetes event
type EventRecorder struct {
        record.EventRecorder
}

// NewEventRecorder - create new event recorder from rect config
func NewEventRecorder(cfg *rest.Config, scheme *apiruntime.Scheme) (*EventRecorder, error) <span class="cov8" title="1">{
        reccs, err := kubernetes.NewForConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to new clientset for event recorder. err: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">rec := &amp;EventRecorder{}
        eventBroadcaster := record.NewBroadcaster()
        eventBroadcaster.StartLogging(klog.Infof)
        eventBroadcaster.StartRecordingToSink(&amp;typedcorev1.EventSinkImpl{Interface: reccs.CoreV1().Events("")})

        rec.EventRecorder = eventBroadcaster.NewRecorder(scheme, corev1.EventSource{Component: "subscription"})

        return rec, nil</span>
}

// RecordEvent - record kuberentes event
func (rec *EventRecorder) RecordEvent(obj apiruntime.Object, reason, msg string, err error) <span class="cov8" title="1">{
        eventType := corev1.EventTypeNormal
        evnetMsg := msg

        if err != nil </span><span class="cov8" title="1">{
                eventType = corev1.EventTypeWarning
        }</span>

        <span class="cov8" title="1">rec.EventRecorder.Event(obj, eventType, reason, evnetMsg)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import "os"

func GetTestGitRepoURLFromEnvVar() string <span class="cov8" title="1">{
        return os.Getenv("TEST_GIT_REPO_URL")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2020 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "bytes"
        "context"
        "crypto/tls"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "errors"
        "fmt"
        "io/ioutil"
        "net/http"
        "net/url"
        "os"
        "os/exec"
        "path/filepath"
        "time"

        gitssh "github.com/go-git/go-git/v5/plumbing/transport/ssh"
        "golang.org/x/crypto/ssh"
        "golang.org/x/crypto/ssh/knownhosts"
        "gopkg.in/src-d/go-git.v4"
        "gopkg.in/src-d/go-git.v4/plumbing"
        admissionv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/klog/v2"

        "strings"

        "github.com/google/go-github/v42/github"
        gitignore "github.com/sabhiram/go-gitignore"

        "github.com/ghodss/yaml"
        gitclient "gopkg.in/src-d/go-git.v4/plumbing/transport/client"
        githttp "gopkg.in/src-d/go-git.v4/plumbing/transport/http"
        "sigs.k8s.io/controller-runtime/pkg/client"

        chnv1 "open-cluster-management.io/multicloud-operators-channel/pkg/apis/apps/v1"
        appv1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1"
)

const (
        // UserID is key of GitHub user ID in secret
        UserID = "user"
        // AccessToken is key of GitHub user password or personal token in secret
        AccessToken = "accessToken"
        // SSHKey is use to connect to the channel via SSH
        SSHKey = "sshKey"
        // Passphrase is used to open the SSH key
        Passphrase = "passphrase"
        // ClientKey is a client private key for connecting to a Git server
        ClientKey = "clientKey"
        // ClientCert is a client certificate for connecting to a Git server
        ClientCert = "clientCert"

        Error = " err: "
)

type kubeResource struct {
        APIVersion string `yaml:"apiVersion"`
        Kind       string `yaml:"kind"`
}

//KKubeResource export the kuKubeResource for other package
type KubeResource struct {
        kubeResource
}

type GitCloneOption struct {
        CommitHash                string
        RevisionTag               string
        Branch                    plumbing.ReferenceName
        DestDir                   string
        CloneDepth                int
        PrimaryConnectionOption   *ChannelConnectionCfg
        SecondaryConnectionOption *ChannelConnectionCfg
}

type ChannelConnectionCfg struct {
        RepoURL            string
        User               string
        Password           string
        SSHKey             []byte
        Passphrase         []byte
        InsecureSkipVerify bool
        CaCerts            string
        ClientKey          []byte
        ClientCert         []byte
}

// ParseKubeResoures parses a YAML content and returns kube resources in byte array from the file
func ParseKubeResoures(file []byte) [][]byte <span class="cov8" title="1">{
        cond := func(t KubeResource) bool </span><span class="cov8" title="1">{
                return t.APIVersion == "" || t.Kind == ""
        }</span>

        <span class="cov8" title="1">return KubeResourceParser(file, cond)</span>
}

type Kube func(KubeResource) bool

func KubeResourceParser(file []byte, cond Kube) [][]byte <span class="cov8" title="1">{
        var ret [][]byte

        items := ParseYAML(file)

        for _, i := range items </span><span class="cov8" title="1">{
                item := []byte(strings.Trim(i, "\t \n"))

                t := KubeResource{}
                err := yaml.Unmarshal(item, &amp;t)

                if err != nil </span><span class="cov0" title="0">{
                        // Ignore item that cannot be unmarshalled..
                        klog.Warning(err, "Failed to unmarshal YAML content")
                        continue</span>
                }

                <span class="cov8" title="1">if cond(t) </span><span class="cov8" title="1">{
                        // Ignore item that does not have apiVersion or kind.
                        klog.Warning("Not a Kubernetes resource")
                }</span> else<span class="cov8" title="1"> {
                        ret = append(ret, item)
                }</span>
        }

        <span class="cov8" title="1">return ret</span>
}

func getCertChain(certs string) tls.Certificate <span class="cov8" title="1">{
        var certChain tls.Certificate

        certPEMBlock := []byte(certs)

        var certDERBlock *pem.Block

        for </span><span class="cov8" title="1">{
                certDERBlock, certPEMBlock = pem.Decode(certPEMBlock)

                if certDERBlock == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if certDERBlock.Type == "CERTIFICATE" </span><span class="cov8" title="1">{
                        certChain.Certificate = append(certChain.Certificate, certDERBlock.Bytes)
                }</span>
        }

        <span class="cov8" title="1">return certChain</span>
}

// A subscription can have secondary channel to use when it cannot connect to the primary channel
// This builds connectionOptions *git.CloneOptions based on the channel selection
func getConnectionOptions(cloneOptions *GitCloneOption, primary bool) (connectionOptions *git.CloneOptions, err error) <span class="cov0" title="0">{
        channelConnOptions := cloneOptions.PrimaryConnectionOption

        if !primary </span><span class="cov0" title="0">{
                if cloneOptions.SecondaryConnectionOption == nil </span><span class="cov0" title="0">{
                        klog.Error("no secondary channel to try")
                        return nil, nil
                }</span>

                <span class="cov0" title="0">channelConnOptions = cloneOptions.SecondaryConnectionOption</span>
        }

        <span class="cov0" title="0">options := &amp;git.CloneOptions{
                URL:               channelConnOptions.RepoURL,
                SingleBranch:      true,
                RecurseSubmodules: git.DefaultSubmoduleRecursionDepth,
                ReferenceName:     cloneOptions.Branch,
        }

        // The destination directory needs to be created here
        err = os.RemoveAll(cloneOptions.DestDir)

        if err != nil </span><span class="cov0" title="0">{
                klog.Warning(err, "Failed to remove directory ", cloneOptions.DestDir)
        }</span>

        <span class="cov0" title="0">err = os.MkdirAll(cloneOptions.DestDir, os.ModePerm)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If branch name is provided, clone the specified branch only.
        <span class="cov0" title="0">if cloneOptions.Branch != "" </span><span class="cov0" title="0">{
                options.ReferenceName = cloneOptions.Branch
                options.SingleBranch = true
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(options.URL, "http") </span><span class="cov0" title="0">{
                klog.Info("Connecting to Git server via HTTP")

                err := getHTTPOptions(options,
                        channelConnOptions.User,
                        channelConnOptions.Password,
                        channelConnOptions.CaCerts,
                        channelConnOptions.InsecureSkipVerify,
                        channelConnOptions.ClientKey,
                        channelConnOptions.ClientCert)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err, "failed to prepare HTTP clone options")
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                klog.Info("Connecting to Git server via SSH")

                knownhostsfile := filepath.Join(cloneOptions.DestDir, "known_hosts")

                if !channelConnOptions.InsecureSkipVerify </span><span class="cov0" title="0">{
                        err := getKnownHostFromURL(channelConnOptions.RepoURL, knownhostsfile)

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">err = getSSHOptions(options, channelConnOptions.SSHKey, channelConnOptions.Passphrase, knownhostsfile, channelConnOptions.InsecureSkipVerify)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err, " failed to prepare SSH clone options")
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">options.Depth = 1

        if cloneOptions.CommitHash != "" || cloneOptions.RevisionTag != "" </span><span class="cov0" title="0">{
                if cloneOptions.CloneDepth &gt; 1 </span><span class="cov0" title="0">{
                        klog.Infof("Setting clone depth to %d", cloneOptions.CloneDepth)
                        options.Depth = cloneOptions.CloneDepth
                }</span> else<span class="cov0" title="0"> {
                        klog.Info("Setting clone depth to 20")
                        options.Depth = 20
                }</span>
        }

        <span class="cov0" title="0">return options, nil</span>
}

// CloneGitRepo clones a GitHub repository
func CloneGitRepo(cloneOptions *GitCloneOption) (commitID string, err error) <span class="cov0" title="0">{
        usingPrimary := true

        options, err := getConnectionOptions(cloneOptions, true)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to get Git clone options with the primary channel. Trying the secondary channel.")

                usingPrimary = false
        }</span>

        <span class="cov0" title="0">secondaryOptions, err := getConnectionOptions(cloneOptions, false)

        if err != nil </span><span class="cov0" title="0">{
                if !usingPrimary </span><span class="cov0" title="0">{
                        // we could not get both primary and secondary Git connection options. return error
                        klog.Error("Failed to get Git clone options with the secondary channel.")
                        return "", err
                }</span>

                <span class="cov0" title="0">klog.Warning("Failed to get Git clone options with the secondary channel.")</span>
        }

        // we could not get the connection options with the primary channel but we got it with the secondary channel. Use it instead
        <span class="cov0" title="0">if !usingPrimary </span><span class="cov0" title="0">{
                if secondaryOptions == nil </span><span class="cov0" title="0">{
                        // if trying the secondary connection option but nothing there, return error
                        // at this point, we have no Git connection options
                        return "", errors.New("failed to build git connection options")
                }</span>

                <span class="cov0" title="0">options = secondaryOptions</span>
        }

        <span class="cov0" title="0">klog.Info("Cloning ", options.URL, " into ", cloneOptions.DestDir)

        klog.Info("cloneOptions.DestDir = " + cloneOptions.DestDir)
        klog.Info("cloneOptions.Branch = " + cloneOptions.Branch)
        klog.Info("cloneOptions.CommitHash = " + cloneOptions.CommitHash)
        klog.Info("cloneOptions.RevisionTag = " + cloneOptions.RevisionTag)
        klog.Infof("cloneOptions.CloneDepth = %d", cloneOptions.CloneDepth)

        repo, err := git.PlainClone(cloneOptions.DestDir, false, options)

        if err != nil </span><span class="cov0" title="0">{
                if usingPrimary </span><span class="cov0" title="0">{
                        klog.Error(err, " Failed to git clone with the primary channel: ", err.Error())

                        if secondaryOptions == nil </span><span class="cov0" title="0">{
                                return "", errors.New("Failed to clone git: " + options.URL + Error + err.Error())
                        }</span>

                        <span class="cov0" title="0">klog.Info("Trying to clone with the secondary channel")
                        klog.Info("Cloning ", secondaryOptions.URL, " into ", cloneOptions.DestDir)

                        repo, err = git.PlainClone(cloneOptions.DestDir, false, secondaryOptions)

                        if err != nil </span><span class="cov0" title="0">{
                                klog.Error("Failed to clone Git with the secondary channel." + Error + err.Error())

                                return "", errors.New("Failed to clone git: " + secondaryOptions.URL + " branch: " + cloneOptions.Branch.String() + Error + err.Error())
                        }</span>
                } else<span class="cov0" title="0"> {
                        return "", errors.New("Failed to clone git: " + options.URL + " branch: " + cloneOptions.Branch.String() + Error + err.Error())
                }</span>
        }

        <span class="cov0" title="0">ref, err := repo.Head()
        if err != nil </span><span class="cov0" title="0">{
                klog.Error(err, " Failed to get git repo head")
                return "", errors.New("failed to get git repo head," + Error + err.Error())
        }</span>

        <span class="cov0" title="0">klog.Infof("Successfully cloned the repo and the current branch is %s", ref.Name().Short())

        // If both commitHash and revisionTag are provided, take commitHash.
        targetCommit := cloneOptions.CommitHash

        if cloneOptions.RevisionTag != "" &amp;&amp; targetCommit == "" </span><span class="cov0" title="0">{
                tag := "refs/tags/" + cloneOptions.RevisionTag
                releasetag := plumbing.Revision(tag)

                revisionHash, err := repo.ResolveRevision(releasetag)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err, " failed to resolve revision")
                        return "", errors.New("failed to resolve revision tag " + cloneOptions.RevisionTag + Error + err.Error())
                }</span>

                <span class="cov0" title="0">klog.Infof("Revision tag %s is resolved to %s", cloneOptions.RevisionTag, revisionHash)
                targetCommit = revisionHash.String()</span>
        }

        <span class="cov0" title="0">if targetCommit != "" </span><span class="cov0" title="0">{
                workTree, err := repo.Worktree()

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err, " Failed to get work tree")
                        return "", err
                }</span>

                <span class="cov0" title="0">klog.Infof("Checking out commit %s ", targetCommit)

                err = workTree.Checkout(&amp;git.CheckoutOptions{
                        Hash:   plumbing.NewHash(strings.TrimSpace(targetCommit)),
                        Create: false,
                })

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err, " Failed to checkout commit")
                        return "", errors.New("failed to checkout commit " + targetCommit + Error + err.Error())
                }</span>

                <span class="cov0" title="0">klog.Infof("Successfully checked out commit %s ", targetCommit)

                return targetCommit, nil</span>
        }

        // Otherwise return the latest commit ID
        <span class="cov0" title="0">commit, err := repo.CommitObject(ref.Hash())

        if err != nil </span><span class="cov0" title="0">{
                klog.Error(err, " Failed to get git repo commit")
                return "", errors.New("failed to get the repo's latest commit hash," + Error + err.Error())
        }</span>

        <span class="cov0" title="0">return commit.ID().String(), nil</span>
}

func getKnownHostFromURL(sshURL string, filepath string) error <span class="cov8" title="1">{
        sshhostname := ""
        sshhostport := ""

        if strings.HasPrefix(sshURL, "ssh:") </span><span class="cov8" title="1">{
                u, err := url.Parse(sshURL)

                if err != nil </span><span class="cov8" title="1">{
                        klog.Error("failed toparse SSH URL: ", err)
                        return err
                }</span>

                <span class="cov8" title="1">sshhostname = u.Hostname()
                sshhostport = u.Port()</span>
        } else<span class="cov8" title="1"> if strings.HasPrefix(sshURL, "git@") </span><span class="cov8" title="1">{
                sshhostname = strings.Split(strings.SplitAfter(sshURL, "@")[1], ":")[0]
        }</span>

        <span class="cov8" title="1">klog.Info("sshhostname =  " + sshhostname)
        klog.Info("sshhostport =  " + sshhostport)

        klog.Info("Getting public SSH host key for " + sshhostname)

        cmd := exec.Command("ssh-keyscan", sshhostname) // #nosec G204 the variable is generated within this function.

        if sshhostport != "" </span><span class="cov8" title="1">{
                cmd = exec.Command("ssh-keyscan", sshhostname, "-p", sshhostport) // #nosec G204 the variable is generated within this function.
                klog.Infof("Running command ssh-keyscan %s -p %s", sshhostname, sshhostport)
        }</span>

        <span class="cov8" title="1">stdout, err := cmd.Output()

        if err != nil </span><span class="cov8" title="1">{
                klog.Error("failed to get public SSH host key: ", err)
        }</span>

        <span class="cov8" title="1">klog.Info("SSH host key: " + string(stdout))

        if err := ioutil.WriteFile(filepath, stdout, 0600); err != nil </span><span class="cov8" title="1">{
                klog.Error("failed to write known_hosts file: ", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getSSHOptions(options *git.CloneOptions, sshKey, passphrase []byte, knownhostsfile string, insecureSkipVerify bool) error <span class="cov0" title="0">{
        publicKey := &amp;gitssh.PublicKeys{}
        publicKey.User = "git"

        if len(passphrase) &gt; 0 </span><span class="cov0" title="0">{
                klog.Info("Parsing SSH private key with passphrase")

                signer, err := ssh.ParsePrivateKeyWithPassphrase(sshKey, passphrase)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error("failed to parse SSH key", err.Error())
                        return err
                }</span>

                <span class="cov0" title="0">publicKey.Signer = signer</span>
        } else<span class="cov0" title="0"> {
                signer, err := ssh.ParsePrivateKey(sshKey)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Error("failed to parse SSH key", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">publicKey.Signer = signer</span>
        }

        <span class="cov0" title="0">if insecureSkipVerify </span><span class="cov0" title="0">{
                klog.Info("Insecure ignore SSH host key")

                publicKey.HostKeyCallback = ssh.InsecureIgnoreHostKey() // #nosec G106 this is optional and used only if users specify it in channel configuration
        }</span> else<span class="cov0" title="0"> {
                klog.Info("Using SSH known host keys")
                callback, err := knownhosts.New(knownhostsfile)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error("failed to get knownhosts ", err)
                        return err
                }</span>

                <span class="cov0" title="0">publicKey.HostKeyCallback = callback</span>
        }

        <span class="cov0" title="0">options.Auth = publicKey

        return nil</span>
}

func getHTTPOptions(options *git.CloneOptions, user, password, caCerts string, insecureSkipVerify bool, clientkey, clientcert []byte) error <span class="cov0" title="0">{
        if user != "" &amp;&amp; password != "" </span><span class="cov0" title="0">{
                options.Auth = &amp;githttp.BasicAuth{
                        Username: user,
                        Password: password,
                }
        }</span>

        <span class="cov0" title="0">installProtocol := false

        clientConfig := &amp;tls.Config{MinVersion: tls.VersionTLS12}

        // skip TLS certificate verification for Git servers with custom or self-signed certs
        if insecureSkipVerify </span><span class="cov0" title="0">{
                klog.Info("insecureSkipVerify = true, skipping Git server's certificate verification.")

                clientConfig.InsecureSkipVerify = true

                installProtocol = true
        }</span> else<span class="cov0" title="0"> if !strings.EqualFold(caCerts, "") </span><span class="cov0" title="0">{
                klog.Info("Adding Git server's CA certificate to trust certificate pool")

                // Load the host's trusted certs into memory
                certPool, _ := x509.SystemCertPool()
                if certPool == nil </span><span class="cov0" title="0">{
                        certPool = x509.NewCertPool()
                }</span>

                <span class="cov0" title="0">certChain := getCertChain(caCerts)

                if len(certChain.Certificate) == 0 </span><span class="cov0" title="0">{
                        klog.Warning("No certificate found")
                }</span>

                // Add CA certs from the channel config map to the cert pool
                // It will not add duplicate certs
                <span class="cov0" title="0">for _, cert := range certChain.Certificate </span><span class="cov0" title="0">{
                        x509Cert, err := x509.ParseCertificate(cert)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">klog.Info("Adding certificate --&gt;" + x509Cert.Subject.String())
                        certPool.AddCert(x509Cert)</span>
                }

                <span class="cov0" title="0">clientConfig.RootCAs = certPool

                installProtocol = true</span>
        }

        // If client key pair is provided, make mTLS connection
        <span class="cov0" title="0">if len(clientkey) &gt; 0 &amp;&amp; len(clientcert) &gt; 0 </span><span class="cov0" title="0">{
                klog.Info("Client certificate key pair is provieded. Making mTLS connection.")

                clientCertificate, err := tls.X509KeyPair(clientcert, clientkey)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err.Error())
                        return err
                }</span>

                // Add the client certificate in the connection
                <span class="cov0" title="0">clientConfig.Certificates = []tls.Certificate{clientCertificate}

                klog.Info("Client certificate key pair added successfully")</span>
        }

        <span class="cov0" title="0">if installProtocol </span><span class="cov0" title="0">{
                klog.Info("HTTP_PROXY = " + os.Getenv("HTTP_PROXY"))
                klog.Info("HTTPS_PROXY = " + os.Getenv("HTTPS_PROXY"))
                klog.Info("NO_PROXY = " + os.Getenv("NO_PROXY"))

                transportConfig := &amp;http.Transport{
                        /* #nosec G402 */
                        TLSClientConfig: clientConfig,
                }

                proxyURLEnv := ""

                if os.Getenv("HTTPS_PROXY") != "" </span><span class="cov0" title="0">{
                        proxyURLEnv = os.Getenv("HTTPS_PROXY")
                }</span> else<span class="cov0" title="0"> if os.Getenv("HTTP_PROXY") != "" </span><span class="cov0" title="0">{
                        proxyURLEnv = os.Getenv("HTTP_PROXY")
                }</span> else<span class="cov0" title="0"> if os.Getenv("NO_PROXY") != "" </span><span class="cov0" title="0">{
                        proxyURLEnv = os.Getenv("NO_PROXY")
                }</span>

                <span class="cov0" title="0">if proxyURLEnv != "" </span><span class="cov0" title="0">{
                        transportConfig.Proxy = http.ProxyFromEnvironment

                        klog.Info("HTTP transport proxy set")
                }</span>

                <span class="cov0" title="0">customClient := &amp;http.Client{
                        /* #nosec G402 */
                        Transport: transportConfig,

                        // 15 second timeout
                        Timeout: 15 * time.Second,

                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse
                        }</span>,
                }

                <span class="cov0" title="0">gitclient.InstallProtocol("https", githttp.NewClient(customClient))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetSubscriptionBranch returns GitHub repo branch for a given subscription
func GetSubscriptionBranch(sub *appv1.Subscription) plumbing.ReferenceName <span class="cov8" title="1">{
        annotations := sub.GetAnnotations()
        branchStr := annotations[appv1.AnnotationGitBranch]

        if branchStr == "" </span><span class="cov8" title="1">{
                branchStr = annotations[appv1.AnnotationGithubBranch] // AnnotationGithubBranch will be depricated
        }</span>

        <span class="cov8" title="1">return GetSubscriptionBranchRef(branchStr)</span>
}

func GetSubscriptionBranchRef(b string) plumbing.ReferenceName <span class="cov8" title="1">{
        if b != "" </span><span class="cov8" title="1">{
                if !strings.HasPrefix(b, "refs/heads/") </span><span class="cov8" title="1">{
                        b = "refs/heads/" + b
                }</span>

                <span class="cov8" title="1">return plumbing.ReferenceName(b)</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// GetChannelSecret returns username and password for channel
func GetChannelSecret(client client.Client, chn *chnv1.Channel) (string, string, []byte, []byte, []byte, []byte, error) <span class="cov8" title="1">{
        username := ""
        accessToken := ""
        sshKey := []byte("")
        passphrase := []byte("")
        clientkey := []byte("")
        clientcert := []byte("")

        if chn.Spec.SecretRef != nil </span><span class="cov8" title="1">{
                secret := &amp;corev1.Secret{}
                secns := chn.Spec.SecretRef.Namespace

                if secns == "" </span><span class="cov8" title="1">{
                        secns = chn.Namespace
                }</span>

                <span class="cov8" title="1">err := client.Get(context.TODO(), types.NamespacedName{Name: chn.Spec.SecretRef.Name, Namespace: secns}, secret)
                if err != nil </span><span class="cov8" title="1">{
                        klog.Error(err, "Unable to get secret from local cluster.")
                        return username, accessToken, sshKey, passphrase, clientkey, clientcert, err
                }</span>

                <span class="cov8" title="1">username, accessToken, sshKey, passphrase, clientkey, clientcert, err = ParseChannelSecret(secret)

                if err != nil </span><span class="cov8" title="1">{
                        return username, accessToken, sshKey, passphrase, clientkey, clientcert, err
                }</span>
        }

        <span class="cov8" title="1">return username, accessToken, sshKey, passphrase, clientkey, clientcert, nil</span>
}

// GetDataFromChannelConfigMap returns username and password for channel
func GetChannelConfigMap(client client.Client, chn *chnv1.Channel) *corev1.ConfigMap <span class="cov0" title="0">{
        if chn.Spec.ConfigMapRef != nil </span><span class="cov0" title="0">{
                configMapRet := &amp;corev1.ConfigMap{}

                cmns := chn.Namespace

                err := client.Get(context.TODO(), types.NamespacedName{Name: chn.Spec.ConfigMapRef.Name, Namespace: cmns}, configMapRet)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err, "Unable to get config map from local cluster.")
                        return nil
                }</span>

                <span class="cov0" title="0">return configMapRet</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ParseChannelSecret(secret *corev1.Secret) (string, string, []byte, []byte, []byte, []byte, error) <span class="cov8" title="1">{
        username := ""
        accessToken := ""
        sshKey := []byte("")
        passphrase := []byte("")
        clientKey := []byte("")
        clientCert := []byte("")
        err := yaml.Unmarshal(secret.Data[UserID], &amp;username)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error(err, "Failed to unmarshal username from the secret.")
                return username, accessToken, sshKey, passphrase, clientKey, clientCert, err
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(secret.Data[AccessToken], &amp;accessToken)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error(err, "Failed to unmarshal accessToken from the secret.")
                return username, accessToken, sshKey, passphrase, clientKey, clientCert, err
        }</span>

        <span class="cov8" title="1">sshKey = bytes.TrimSpace(secret.Data[SSHKey])
        passphrase = bytes.TrimSpace(secret.Data[Passphrase])
        clientKey = bytes.TrimSpace(secret.Data[ClientKey])
        clientCert = bytes.TrimSpace(secret.Data[ClientCert])

        if (len(clientKey) == 0 &amp;&amp; len(clientCert) &gt; 0) || (len(clientKey) &gt; 0 &amp;&amp; len(clientCert) == 0) </span><span class="cov0" title="0">{
                klog.Error(err, "for mTLS connection to Git, both clientKey (private key) and clientCert (certificate) are required in the channel secret")
                return username, accessToken, sshKey, passphrase, clientKey, clientCert,
                        errors.New("for mTLS connection to Git, both clientKey (private key) and clientCert (certificate) are required in the channel secret")
        }</span>

        <span class="cov8" title="1">if len(sshKey) == 0 &amp;&amp; len(clientKey) == 0 </span><span class="cov8" title="1">{
                if username == "" || accessToken == "" </span><span class="cov8" title="1">{
                        klog.Error(err, "sshKey (and optionally passphrase) or user and accressToken need to be specified in the channel secret")
                        return username, accessToken, sshKey, passphrase, clientKey, clientCert,
                                errors.New("ssh_key (and optionally passphrase) or user and accressToken need to be specified in the channel secret")
                }</span>
        }

        <span class="cov8" title="1">return username, accessToken, sshKey, passphrase, clientKey, clientCert, nil</span>
}

// GetLocalGitFolder returns the local Git repo clone directory
func GetLocalGitFolder(sub *appv1.Subscription) string <span class="cov0" title="0">{
        return filepath.Join(os.TempDir(), sub.Namespace, sub.Name)
}</span>

type SkipFunc func(string, string) bool

// SortResources sorts kube resources into different arrays for processing them later.
func SortResources(repoRoot, resourcePath string, skips ...SkipFunc) (map[string]string, map[string]string, []string, []string, []string, error) <span class="cov8" title="1">{
        klog.V(4).Info("Git repo subscription directory: ", resourcePath)

        var skip SkipFunc

        if len(skips) == 0 </span><span class="cov8" title="1">{
                skip = func(string, string) bool </span><span class="cov8" title="1">{ return false }</span>
        } else<span class="cov0" title="0"> {
                skip = skips[0]
        }</span>

        // In the cloned git repo root, find all helm chart directories
        <span class="cov8" title="1">chartDirs := make(map[string]string)

        // In the cloned git repo root, find all kustomization directories
        kustomizeDirs := make(map[string]string)

        // Apply CustomResourceDefinition and Namespace Kubernetes resources first
        crdsAndNamespaceFiles := []string{}
        // Then apply ServiceAccount, ClusterRole and Role Kubernetes resources next
        rbacFiles := []string{}
        // Then apply the rest of resource
        otherFiles := []string{}

        currentChartDir := "NONE"
        currentKustomizeDir := "NONE"

        kubeIgnore := GetKubeIgnore(resourcePath)

        err := filepath.Walk(resourcePath,
                func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">relativePath := path

                        if len(strings.SplitAfter(path, repoRoot+"/")) &gt; 1 </span><span class="cov8" title="1">{
                                relativePath = strings.SplitAfter(path, repoRoot+"/")[1]
                        }</span>

                        <span class="cov8" title="1">if !kubeIgnore.MatchesPath(relativePath) &amp;&amp; !skip(resourcePath, path) </span><span class="cov8" title="1">{
                                if info.IsDir() </span><span class="cov8" title="1">{
                                        klog.V(4).Info("Ignoring subfolders of ", currentChartDir)
                                        if _, err := os.Stat(path + "/Chart.yaml"); err == nil </span><span class="cov8" title="1">{
                                                klog.V(4).Info("Found Chart.yaml in ", path)
                                                if !strings.HasPrefix(path, currentChartDir) </span><span class="cov8" title="1">{
                                                        klog.V(4).Info("This is a helm chart folder.")
                                                        chartDirs[path+"/"] = path + "/"
                                                        currentChartDir = path + "/"
                                                }</span>
                                        } else<span class="cov8" title="1"> if _, err := os.Stat(path + "/kustomization.yaml"); err == nil </span><span class="cov8" title="1">{
                                                // If there are nested kustomizations or any other folder structures containing kube
                                                // resources under a kustomization, subscription should not process them and let kustomize
                                                // build handle them based on the top-level kustomization.yaml.
                                                if !strings.HasPrefix(path, currentKustomizeDir) </span><span class="cov8" title="1">{
                                                        klog.V(4).Info("Found kustomization.yaml in ", path)
                                                        currentKustomizeDir = path + "/"
                                                        kustomizeDirs[path+"/"] = path + "/"
                                                }</span>
                                        } else<span class="cov8" title="1"> if _, err := os.Stat(path + "/kustomization.yml"); err == nil </span><span class="cov8" title="1">{
                                                // If there are nested kustomizations or any other folder structures containing kube
                                                // resources under a kustomization, subscription should not process them and let kustomize
                                                // build handle them based on the top-level kustomization.yaml
                                                if !strings.HasPrefix(path, currentKustomizeDir) </span><span class="cov8" title="1">{
                                                        klog.V(4).Info("Found kustomization.yml in ", path)
                                                        currentKustomizeDir = path + "/"
                                                        kustomizeDirs[path+"/"] = path + "/"
                                                }</span>
                                        }
                                } else<span class="cov8" title="1"> if !strings.HasPrefix(path, currentChartDir) &amp;&amp;
                                        !strings.HasPrefix(path, repoRoot+"/.git") &amp;&amp;
                                        !strings.HasPrefix(path, currentKustomizeDir) </span><span class="cov8" title="1">{
                                        // Do not process kubernetes YAML files under helm chart or kustomization directory
                                        // If there are nested kustomizations or any other folder structures containing kube
                                        // resources under a kustomization, subscription should not process them and let kustomize
                                        // build handle them based on the top-level kustomization.yaml
                                        crdsAndNamespaceFiles, rbacFiles, otherFiles, err = sortKubeResource(crdsAndNamespaceFiles, rbacFiles, otherFiles, path)
                                        if err != nil </span><span class="cov0" title="0">{
                                                klog.Error(err.Error())
                                                return err
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">return nil</span>
                })

        <span class="cov8" title="1">return chartDirs, kustomizeDirs, crdsAndNamespaceFiles, rbacFiles, otherFiles, err</span>
}

func sortKubeResource(crdsAndNamespaceFiles, rbacFiles, otherFiles []string, path string) ([]string, []string, []string, error) <span class="cov8" title="1">{
        if strings.EqualFold(filepath.Ext(path), ".yml") || strings.EqualFold(filepath.Ext(path), ".yaml") </span><span class="cov8" title="1">{
                klog.V(4).Info("Reading file: ", path)

                file, err := ioutil.ReadFile(path) // #nosec G304 path is not user input

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err, "Failed to read YAML file "+path)
                        return crdsAndNamespaceFiles, rbacFiles, otherFiles, err
                }</span>

                <span class="cov8" title="1">resources := ParseKubeResoures(file)

                if len(resources) == 1 </span><span class="cov8" title="1">{
                        t := kubeResource{}
                        err := yaml.Unmarshal(resources[0], &amp;t)

                        if err != nil </span><span class="cov0" title="0">{
                                klog.Warning("Failed to unmarshal YAML file")
                                // Just ignore the YAML
                                return crdsAndNamespaceFiles, rbacFiles, otherFiles, nil
                        }</span>

                        <span class="cov8" title="1">if t.APIVersion != "" &amp;&amp; t.Kind != "" </span><span class="cov8" title="1">{
                                if strings.EqualFold(t.Kind, "customresourcedefinition") </span><span class="cov8" title="1">{
                                        crdsAndNamespaceFiles = append(crdsAndNamespaceFiles, path)
                                }</span> else<span class="cov8" title="1"> if strings.EqualFold(t.Kind, "namespace") </span><span class="cov8" title="1">{
                                        crdsAndNamespaceFiles = append(crdsAndNamespaceFiles, path)
                                }</span> else<span class="cov8" title="1"> if strings.EqualFold(t.Kind, "serviceaccount") ||
                                        strings.EqualFold(t.Kind, "clusterrole") ||
                                        strings.EqualFold(t.Kind, "role") ||
                                        strings.EqualFold(t.Kind, "clusterrolebinding") ||
                                        strings.EqualFold(t.Kind, "rolebinding") </span><span class="cov8" title="1">{
                                        rbacFiles = append(rbacFiles, path)
                                }</span> else<span class="cov8" title="1"> {
                                        otherFiles = append(otherFiles, path)
                                }</span>
                        }
                } else<span class="cov8" title="1"> if len(resources) &gt; 1 </span><span class="cov8" title="1">{
                        klog.Info("Multi resource")
                        otherFiles = append(otherFiles, path)
                }</span>
        }

        <span class="cov8" title="1">return crdsAndNamespaceFiles, rbacFiles, otherFiles, nil</span>
}

func SkipHooksOnManaged(resourcePath, curPath string) bool <span class="cov8" title="1">{
        PREHOOK := "prehook"
        POSTHOOK := "posthook"

        // of the resource root.
        pre := fmt.Sprintf("%s/%s", resourcePath, PREHOOK)
        post := fmt.Sprintf("%s/%s", resourcePath, POSTHOOK)

        return strings.HasPrefix(curPath, pre) || strings.HasPrefix(curPath, post)
}</span>

// GetKubeIgnore get .kubernetesignore list
func GetKubeIgnore(resourcePath string) *gitignore.GitIgnore <span class="cov8" title="1">{
        klog.V(4).Info("Git repo resource root directory: ", resourcePath)

        lines := []string{""}
        kubeIgnore := gitignore.CompileIgnoreLines(lines...)

        if _, err := os.Stat(filepath.Join(resourcePath, ".kubernetesignore")); err == nil </span><span class="cov8" title="1">{
                klog.V(4).Info("Found .kubernetesignore in ", resourcePath)
                kubeIgnore, _ = gitignore.CompileIgnoreFile(filepath.Join(resourcePath, ".kubernetesignore"))
        }</span>

        <span class="cov8" title="1">return kubeIgnore</span>
}

// IsGitChannel returns true if channel type is github or git
func IsGitChannel(chType string) bool <span class="cov8" title="1">{
        return strings.EqualFold(chType, chnv1.ChannelTypeGitHub) ||
                strings.EqualFold(chType, chnv1.ChannelTypeGit)
}</span>

func IsClusterAdmin(client client.Client, sub *appv1.Subscription, eventRecorder *EventRecorder) bool <span class="cov8" title="1">{
        isClusterAdmin := false
        isUserSubAdmin := false
        isSubPropagatedFromHub := false
        isClusterAdminAnnotationTrue := false

        userIdentity := ""
        userGroups := ""
        annotations := sub.GetAnnotations()

        if annotations != nil </span><span class="cov8" title="1">{
                encodedUserGroup := strings.Trim(annotations[appv1.AnnotationUserGroup], "")
                encodedUserIdentity := strings.Trim(annotations[appv1.AnnotationUserIdentity], "")

                if encodedUserGroup != "" </span><span class="cov8" title="1">{
                        userGroups = Base64StringDecode(encodedUserGroup)
                }</span>

                <span class="cov8" title="1">if encodedUserIdentity != "" </span><span class="cov8" title="1">{
                        userIdentity = Base64StringDecode(encodedUserIdentity)
                }</span>

                <span class="cov8" title="1">if annotations[appv1.AnnotationHosting] != "" </span><span class="cov8" title="1">{
                        isSubPropagatedFromHub = true
                }</span>

                <span class="cov8" title="1">if strings.EqualFold(annotations[appv1.AnnotationClusterAdmin], "true") </span><span class="cov8" title="1">{
                        isClusterAdminAnnotationTrue = true
                }</span>
        }

        <span class="cov8" title="1">doesWebhookExist := false
        theWebhook := &amp;admissionv1.MutatingWebhookConfiguration{}

        if err := client.Get(context.TODO(), types.NamespacedName{Name: appv1.AcmWebhook}, theWebhook); err == nil </span><span class="cov8" title="1">{
                doesWebhookExist = true
        }</span>

        <span class="cov8" title="1">if userIdentity != "" &amp;&amp; doesWebhookExist </span><span class="cov8" title="1">{
                // First, check open-cluster-management:subscription-admin cluster role binding
                isUserSubAdmin = matchUserSubAdmin(client, userIdentity, userGroups)

                if !isUserSubAdmin </span><span class="cov8" title="1">{
                        // Check if there is any other cluster role binding with open-cluster-management:subscription-admin cluster role
                        isUserSubAdmin = scanUserSubAdmin(client, userIdentity, userGroups)
                }</span>
        }

        // If subscription has cluster-admin:true and propagated from hub and cannot find the webhook, we know we are
        // on the managed cluster so trust the annotations to decide that the subscription is from subscription-admin.
        // But the subscription can also be propagated to the self-managed hub cluster.
        <span class="cov8" title="1">if isClusterAdminAnnotationTrue &amp;&amp; isSubPropagatedFromHub </span><span class="cov8" title="1">{
                if !doesWebhookExist || // not on the hub cluster
                        (doesWebhookExist &amp;&amp; strings.HasSuffix(sub.GetName(), "-local")) </span><span class="cov8" title="1">{ // on the hub cluster and the subscription has -local suffix
                        if eventRecorder != nil </span><span class="cov0" title="0">{
                                eventRecorder.RecordEvent(sub, "RoleElevation",
                                        "Role was elevated to cluster admin for subscription "+sub.Name, nil)
                        }</span>

                        <span class="cov8" title="1">isClusterAdmin = true</span>
                }
        } else<span class="cov8" title="1"> if isUserSubAdmin </span><span class="cov8" title="1">{
                if eventRecorder != nil </span><span class="cov0" title="0">{
                        eventRecorder.RecordEvent(sub, "RoleElevation",
                                "Role was elevated to cluster admin for subscription "+sub.Name+" by user "+userIdentity, nil)
                }</span>

                <span class="cov8" title="1">isClusterAdmin = true</span>
        }

        <span class="cov8" title="1">klog.Infof("isClusterAdmin = %v", isClusterAdmin)

        return isClusterAdmin</span>
}

func matchUserSubAdmin(client client.Client, userIdentity, userGroups string) bool <span class="cov8" title="1">{
        isUserSubAdmin := false
        foundClusterRoleBinding := &amp;rbacv1.ClusterRoleBinding{}

        err := client.Get(context.TODO(), types.NamespacedName{Name: appv1.SubscriptionAdmin}, foundClusterRoleBinding)

        if err == nil </span><span class="cov0" title="0">{
                klog.Infof("ClusterRoleBinding %s found.", appv1.SubscriptionAdmin)

                isUserSubAdmin = checkUserSubAdmin(foundClusterRoleBinding.Subjects, userIdentity, userGroups)
        }</span> else<span class="cov8" title="1"> {
                klog.Error(err)
        }</span>

        <span class="cov8" title="1">foundClusterRoleBinding = nil

        return isUserSubAdmin</span>
}

func scanUserSubAdmin(client client.Client, userIdentity, userGroups string) bool <span class="cov8" title="1">{
        isUserSubAdmin := false

        bindingList := &amp;rbacv1.ClusterRoleBindingList{}

        err := client.List(context.TODO(), bindingList)

        if err == nil </span><span class="cov8" title="1">{
                for _, binding := range bindingList.Items </span><span class="cov8" title="1">{
                        if binding.RoleRef.Kind == "ClusterRole" &amp;&amp; binding.RoleRef.Name == "open-cluster-management:subscription-admin" </span><span class="cov8" title="1">{
                                klog.Infof("Found cluster role binding %s with open-cluster-management:subscription-admin cluster role.", binding.Name)

                                isUserSubAdmin = checkUserSubAdmin(binding.Subjects, userIdentity, userGroups)

                                if isUserSubAdmin </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                }
        } else<span class="cov0" title="0"> {
                klog.Error(err)
        }</span>

        <span class="cov8" title="1">return isUserSubAdmin</span>
}

func checkUserSubAdmin(subjects []rbacv1.Subject, userIdentity, userGroups string) bool <span class="cov8" title="1">{
        isUserSubAdmin := false

        for _, subject := range subjects </span><span class="cov8" title="1">{
                if strings.Trim(subject.Name, "") == strings.Trim(userIdentity, "") &amp;&amp; strings.Trim(subject.Kind, "") == "User" </span><span class="cov8" title="1">{
                        klog.Info("User match. cluster-admin: true")

                        isUserSubAdmin = true
                }</span> else<span class="cov8" title="1"> if subject.Kind == "Group" </span><span class="cov8" title="1">{
                        groupNames := strings.Split(userGroups, ",")

                        for _, groupName := range groupNames </span><span class="cov8" title="1">{
                                if strings.Trim(subject.Name, "") == strings.Trim(groupName, "") </span><span class="cov8" title="1">{
                                        klog.Info("Group match. cluster-admin: true")

                                        isUserSubAdmin = true
                                }</span>
                        }
                } else<span class="cov8" title="1"> if subject.Kind == "ServiceAccount" &amp;&amp; subject.Namespace != "" &amp;&amp; subject.Name != "" </span><span class="cov8" title="1">{
                        if strings.Trim(userIdentity, "") == "system:serviceaccount:"+subject.Namespace+":"+subject.Name </span><span class="cov8" title="1">{
                                klog.Info("ServiceAccount match. cluster-admin: true")

                                isUserSubAdmin = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return isUserSubAdmin</span>
}

func Base64StringDecode(encodedStr string) string <span class="cov8" title="1">{
        decodedBytes, err := base64.StdEncoding.DecodeString(encodedStr)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to base64 decode")
                klog.Error(err)
        }</span>

        <span class="cov8" title="1">return string(decodedBytes)</span>
}

func GetLatestCommitID(url, branch string, clt ...*github.Client) (string, error) <span class="cov8" title="1">{
        gitClt := github.NewClient(nil)
        if len(clt) != 0 </span><span class="cov0" title="0">{
                gitClt = clt[0]
        }</span>

        <span class="cov8" title="1">u, err := getOwnerAndRepo(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">owner, repo := u[0], u[1]
        ctx := context.TODO()

        b, _, err := gitClt.Repositories.GetBranch(ctx, owner, repo, branch, true)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return *b.Commit.SHA, nil</span>
}

func ParseYAML(fileContent []byte) []string <span class="cov8" title="1">{
        fileContentString := string(fileContent)
        lines := strings.Split(fileContentString, "\n")
        newFileContent := []byte("")

        // Multi-document YAML delimeter --- might have trailing spaces. Trim those first.
        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(line, "---") </span><span class="cov8" title="1">{
                        line = strings.Trim(line, " ")
                }</span>

                <span class="cov8" title="1">line += "\n"

                newFileContent = append(newFileContent, line...)</span>
        }

        // Then now split the YAML content using --- delimeter
        <span class="cov8" title="1">items := strings.Split(string(newFileContent), "\n---\n")

        return items</span>
}

func getOwnerAndRepo(url string) ([]string, error) <span class="cov8" title="1">{
        if len(url) == 0 </span><span class="cov8" title="1">{
                return []string{}, nil
        }</span>

        <span class="cov8" title="1">gitSuffix := ".git"

        l1 := strings.Split(url, "//")
        if len(l1) &lt; 1 </span><span class="cov0" title="0">{
                return []string{}, fmt.Errorf("invalid git url l1")
        }</span>

        <span class="cov8" title="1">var l2 string

        if len(l1) == 1 </span><span class="cov8" title="1">{
                l2 = strings.TrimSuffix(l1[0], gitSuffix)
        }</span> else<span class="cov8" title="1"> {
                l2 = strings.TrimSuffix(l1[1], gitSuffix)
        }</span>

        <span class="cov8" title="1">l3 := strings.Split(l2, "/")

        n := len(l3)
        if n &lt; 2 </span><span class="cov8" title="1">{
                return []string{}, fmt.Errorf("invalid git url l2")
        }</span>

        <span class="cov8" title="1">return []string{l3[n-2], l3[n-1]}, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2020 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "strings"

        semver "github.com/Masterminds/semver/v3"
        "github.com/ghodss/yaml"
        "helm.sh/helm/v3/pkg/chartutil"
        "helm.sh/helm/v3/pkg/repo"
        clientsetx "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/klog/v2"
        "sigs.k8s.io/controller-runtime/pkg/client"

        chnv1 "open-cluster-management.io/multicloud-operators-channel/pkg/apis/apps/v1"

        releasev1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/helmrelease/v1"
        appv1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1"
)

func GetPackageAlias(sub *appv1.Subscription, packageName string) string <span class="cov8" title="1">{
        for _, overrides := range sub.Spec.PackageOverrides </span><span class="cov8" title="1">{
                if overrides.PackageName == packageName </span><span class="cov8" title="1">{
                        klog.Infof("Overrides for package %s found", packageName)

                        if overrides.PackageAlias != "" </span><span class="cov8" title="1">{
                                return overrides.PackageAlias
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// GenerateHelmIndexFile generate helm repo index file
func GenerateHelmIndexFile(sub *appv1.Subscription, repoRoot string, chartDirs map[string]string) (*repo.IndexFile, error) <span class="cov8" title="1">{
        // Build a helm repo index file
        indexFile := repo.NewIndexFile()

        for chartDir := range chartDirs </span><span class="cov8" title="1">{
                chartDir = strings.TrimSuffix(chartDir, "/")
                // chartFolderName is chart folder name
                chartFolderName := filepath.Base(chartDir)
                // chartParentDir is the chart folder's parent folder.
                chartParentDir := filepath.Dir(chartDir) + "/"

                // Get the relative parent directory from the git repo root
                chartBaseDir := strings.TrimPrefix(chartParentDir, repoRoot+"/")

                chartMetadata, err := chartutil.LoadChartfile(filepath.Join(chartDir, "Chart.yaml"))

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error("There was a problem in generating helm charts index file: ", err.Error())

                        return indexFile, err
                }</span>

                <span class="cov8" title="1">err = indexFile.MustAdd(chartMetadata, chartFolderName, chartBaseDir, "generated-by-multicloud-operators-subscription")
                if err != nil </span><span class="cov0" title="0">{
                        klog.Warning("There was a problem in adding content to helm charts index file: ", err.Error())
                }</span>
        }

        <span class="cov8" title="1">indexFile.SortEntries()

        err := FilterCharts(sub, indexFile)

        if err != nil </span><span class="cov0" title="0">{
                return indexFile, err
        }</span>

        <span class="cov8" title="1">return indexFile, nil</span>
}

func createSource(channel *chnv1.Channel, chartVersions repo.ChartVersions, sub *appv1.Subscription, packageName string) (*releasev1.Source, error) <span class="cov8" title="1">{
        var source *releasev1.Source

        if IsGitChannel(string(channel.Spec.Type)) </span><span class="cov8" title="1">{
                source = &amp;releasev1.Source{
                        SourceType: releasev1.GitSourceType,
                        Git: &amp;releasev1.Git{
                                Urls:      []string{channel.Spec.Pathname},
                                ChartPath: chartVersions[0].URLs[0],
                                Branch:    GetSubscriptionBranch(sub).Short(),
                        },
                }
        }</span> else<span class="cov8" title="1"> {
                var validURLs []string

                for _, url := range chartVersions[0].URLs </span><span class="cov8" title="1">{
                        if IsURL(url) </span><span class="cov8" title="1">{
                                validURLs = append(validURLs, url)
                        }</span> else<span class="cov8" title="1"> if IsURL(channel.Spec.Pathname + "/" + url) </span><span class="cov8" title="1">{
                                validURLs = append(validURLs, channel.Spec.Pathname+"/"+url)
                        }</span>
                }

                <span class="cov8" title="1">if len(validURLs) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no valid URLs are found for package: %s", packageName)
                }</span>

                <span class="cov8" title="1">source = &amp;releasev1.Source{
                        SourceType: releasev1.HelmRepoSourceType,
                        HelmRepo: &amp;releasev1.HelmRepo{
                                Urls: validURLs,
                        },
                }</span>
        }

        <span class="cov8" title="1">return source, nil</span>
}

func createAltSource(channel *chnv1.Channel, chartVersions repo.ChartVersions, sub *appv1.Subscription, packageName string) (*releasev1.AltSource, error) <span class="cov0" title="0">{
        var altSource *releasev1.AltSource

        if IsGitChannel(string(channel.Spec.Type)) </span><span class="cov0" title="0">{
                altSource = &amp;releasev1.AltSource{
                        SourceType: releasev1.GitSourceType,
                        Git: &amp;releasev1.Git{
                                Urls:      []string{channel.Spec.Pathname},
                                ChartPath: chartVersions[0].URLs[0],
                                Branch:    GetSubscriptionBranch(sub).Short(),
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                var validURLs []string

                for _, url := range chartVersions[0].URLs </span><span class="cov0" title="0">{
                        if IsURL(url) </span><span class="cov0" title="0">{
                                validURLs = append(validURLs, url)
                        }</span> else<span class="cov0" title="0"> if IsURL(channel.Spec.Pathname + "/" + url) </span><span class="cov0" title="0">{
                                validURLs = append(validURLs, channel.Spec.Pathname+"/"+url)
                        }</span>
                }

                <span class="cov0" title="0">if len(validURLs) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no valid URLs are found for package: %s", packageName)
                }</span>

                <span class="cov0" title="0">altSource = &amp;releasev1.AltSource{
                        SourceType: releasev1.HelmRepoSourceType,
                        HelmRepo: &amp;releasev1.HelmRepo{
                                Urls: validURLs,
                        },
                }</span>
        }

        <span class="cov0" title="0">return altSource, nil</span>
}

func CreateOrUpdateHelmChart(
        packageName string,
        releaseCRName string,
        chartVersions repo.ChartVersions,
        client client.Client,
        channel *chnv1.Channel,
        secondaryChannel *chnv1.Channel,
        sub *appv1.Subscription) (helmRelease *releasev1.HelmRelease, err error) <span class="cov8" title="1">{
        helmRelease = &amp;releasev1.HelmRelease{}

        source, err := createSource(channel, chartVersions, sub, packageName)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var altSource *releasev1.AltSource

        if secondaryChannel != nil </span><span class="cov0" title="0">{
                altSource, err = createAltSource(secondaryChannel, chartVersions, sub, packageName)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if secondaryChannel.Spec.ConfigMapRef != nil </span><span class="cov0" title="0">{
                        secondaryChannel.Spec.ConfigMapRef.Namespace = secondaryChannel.Namespace
                }</span>

                <span class="cov0" title="0">if secondaryChannel.Spec.SecretRef != nil </span><span class="cov0" title="0">{
                        secondaryChannel.Spec.SecretRef.Namespace = secondaryChannel.Namespace
                }</span>

                <span class="cov0" title="0">altSource.ConfigMapRef = secondaryChannel.Spec.ConfigMapRef
                altSource.InsecureSkipVerify = secondaryChannel.Spec.InsecureSkipVerify
                altSource.SecretRef = secondaryChannel.Spec.SecretRef

                klog.Infof("Created altSource for helmRelease %s", releaseCRName)</span>
        }

        <span class="cov8" title="1">if channel.Spec.ConfigMapRef != nil </span><span class="cov8" title="1">{
                channel.Spec.ConfigMapRef.Namespace = channel.Namespace
        }</span>

        <span class="cov8" title="1">if channel.Spec.SecretRef != nil </span><span class="cov8" title="1">{
                channel.Spec.SecretRef.Namespace = channel.Namespace
        }</span>

        <span class="cov8" title="1">err = client.Get(context.TODO(),
                types.NamespacedName{Name: releaseCRName, Namespace: sub.Namespace}, helmRelease)

        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        klog.V(2).Infof("Create helmRelease %s", releaseCRName)

                        version := ""
                        digest := ""

                        if len(chartVersions) &gt; 0 &amp;&amp; chartVersions[0] != nil </span><span class="cov8" title="1">{
                                if chartVersions[0].Metadata != nil </span><span class="cov8" title="1">{
                                        version = chartVersions[0].Version
                                }</span>

                                <span class="cov8" title="1">digest = chartVersions[0].Digest</span>
                        }

                        <span class="cov8" title="1">helmRelease = &amp;releasev1.HelmRelease{
                                TypeMeta: metav1.TypeMeta{
                                        APIVersion: "apps.open-cluster-management.io/v1",
                                        Kind:       "HelmRelease",
                                },
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      releaseCRName,
                                        Namespace: sub.Namespace,
                                        OwnerReferences: []metav1.OwnerReference{{
                                                APIVersion: "apps.open-cluster-management.io/v1",
                                                Kind:       "Subscription",
                                                Name:       sub.Name,
                                                UID:        sub.UID,
                                        }},
                                },
                                Repo: releasev1.HelmReleaseRepo{
                                        Source:                        source,
                                        ConfigMapRef:                  channel.Spec.ConfigMapRef,
                                        InsecureSkipVerify:            channel.Spec.InsecureSkipVerify,
                                        SecretRef:                     channel.Spec.SecretRef,
                                        ChartName:                     packageName,
                                        Version:                       version,
                                        Digest:                        digest,
                                        AltSource:                     altSource,
                                        WatchNamespaceScopedResources: sub.Spec.WatchHelmNamespaceScopedResources,
                                },
                        }</span>
                } else<span class="cov0" title="0"> {
                        klog.Error("Error in getting existing helm release", err)
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                // set kind and apiversion, coz it is not in the resource get from k8s
                helmRelease.APIVersion = "apps.open-cluster-management.io/v1"
                helmRelease.Kind = "HelmRelease"
                klog.V(2).Infof("Update helmRelease repo %s", helmRelease.Name)

                version := ""
                digest := ""

                if len(chartVersions) &gt; 0 &amp;&amp; chartVersions[0] != nil </span><span class="cov8" title="1">{
                        if chartVersions[0].Metadata != nil </span><span class="cov8" title="1">{
                                version = chartVersions[0].Version
                        }</span>

                        <span class="cov8" title="1">digest = chartVersions[0].Digest</span>
                }

                // wipe the existing spec, it will be populated by the override helper function later
                <span class="cov8" title="1">helmRelease.Spec = nil

                helmRelease.Repo = releasev1.HelmReleaseRepo{
                        Source:                        source,
                        ConfigMapRef:                  channel.Spec.ConfigMapRef,
                        InsecureSkipVerify:            channel.Spec.InsecureSkipVerify,
                        SecretRef:                     channel.Spec.SecretRef,
                        ChartName:                     packageName,
                        Version:                       version,
                        Digest:                        digest,
                        AltSource:                     altSource,
                        WatchNamespaceScopedResources: sub.Spec.WatchHelmNamespaceScopedResources,
                }</span>
        }

        <span class="cov8" title="1">return helmRelease, nil</span>
}

func Override(helmRelease *releasev1.HelmRelease, sub *appv1.Subscription) error <span class="cov8" title="1">{
        //Overrides with the values provided in the subscription for that package
        overrides := getOverrides(helmRelease.Repo.ChartName, sub)
        data, err := yaml.Marshal(helmRelease)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to mashall ", helmRelease.Name, " err:", err)

                return err
        }</span>

        <span class="cov8" title="1">template := &amp;unstructured.Unstructured{}
        err = yaml.Unmarshal(data, template)

        if err != nil </span><span class="cov0" title="0">{
                klog.Warning("Error while processing helmrelease with template:", helmRelease.Name, err)
        }</span>

        <span class="cov8" title="1">template, err = OverrideTemplate(template, overrides.ClusterOverrides)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to apply override for instance: ", helmRelease.Name, err)

                return err
        }</span>

        <span class="cov8" title="1">data, err = yaml.Marshal(template)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to mashall ", helmRelease.Name, " err:", err)

                return err
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(data, helmRelease)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to unmashall ", helmRelease.Name, " err:", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getShortSubUID(subUID string) string <span class="cov8" title="1">{
        shortUID := subUID

        if len(subUID) &gt;= 5 </span><span class="cov8" title="1">{
                shortUID = subUID[:5]
        }</span>

        <span class="cov8" title="1">return shortUID</span>
}

func PkgToReleaseCRName(sub *appv1.Subscription, packageName string) (string, error) <span class="cov8" title="1">{
        releaseCRName := GetPackageAlias(sub, packageName)
        if releaseCRName == "" </span><span class="cov8" title="1">{
                releaseCRName = packageName
                subUID := string(sub.UID)

                if subUID != "" </span><span class="cov8" title="1">{
                        releaseCRName += "-" + getShortSubUID(subUID)
                }</span>
        }

        <span class="cov8" title="1">releaseCRName, err := GetReleaseName(releaseCRName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return releaseCRName, nil</span>
}

func CreateHelmCRManifest(
        repoURL string,
        packageName string,
        chartVersions repo.ChartVersions,
        client client.Client,
        channel *chnv1.Channel,
        secondaryChannel *chnv1.Channel,
        sub *appv1.Subscription,
        clusterAdmin bool) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        releaseCRName, err := PkgToReleaseCRName(sub, packageName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if channel == nil || !IsGitChannel(string(channel.Spec.Type)) </span><span class="cov8" title="1">{
                for i := range chartVersions[0].URLs </span><span class="cov8" title="1">{
                        parsedURL, err := url.Parse(chartVersions[0].URLs[i])

                        if err != nil </span><span class="cov0" title="0">{
                                klog.Error("Failed to parse url with error:", err)
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if parsedURL.Scheme == "local" </span><span class="cov0" title="0">{
                                //make sure there is one and only one slash
                                repoURL = strings.TrimSuffix(repoURL, "/") + "/"
                                chartVersions[0].URLs[i] = strings.Replace(chartVersions[0].URLs[i], "local://", repoURL, -1)
                        }</span>
                }
        }

        <span class="cov8" title="1">helmRelease, err := CreateOrUpdateHelmChart(
                packageName, releaseCRName, chartVersions, client, channel, secondaryChannel, sub)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to create or update helm chart ", packageName, " err:", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">err = Override(helmRelease, sub)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to override ", helmRelease.Name, " err:", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">if helmRelease.Spec == nil </span><span class="cov8" title="1">{
                spec := make(map[string]interface{})

                err := yaml.Unmarshal([]byte("{\"\":\"\"}"), &amp;spec)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Error("Failed to create an empty spec for helm release", helmRelease)

                        return nil, err
                }</span>

                <span class="cov8" title="1">helmRelease.Spec = spec</span>
        }

        <span class="cov8" title="1">hrLbls := AddPartOfLabel(sub, helmRelease.Labels)
        if hrLbls != nil </span><span class="cov0" title="0">{
                helmRelease.Labels = hrLbls
        }</span>

        <span class="cov8" title="1">if clusterAdmin </span><span class="cov8" title="1">{
                klog.Info("cluster-admin is true.")

                rscAnnotations := helmRelease.GetAnnotations()

                if rscAnnotations == nil </span><span class="cov8" title="1">{
                        rscAnnotations = make(map[string]string)
                }</span>

                <span class="cov8" title="1">rscAnnotations[appv1.AnnotationClusterAdmin] = "true"
                helmRelease.SetAnnotations(rscAnnotations)</span>
        }

        <span class="cov8" title="1">helmReleaseRaw, err := json.Marshal(helmRelease)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to mashall helm release", helmRelease)

                return nil, err
        }</span>

        <span class="cov8" title="1">helmReleaseResource := &amp;unstructured.Unstructured{}
        err = json.Unmarshal(helmReleaseRaw, helmReleaseResource)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to unmashall helm release", helmReleaseResource)

                return nil, err
        }</span>

        <span class="cov8" title="1">return helmReleaseResource, nil</span>
}

func getOverrides(packageName string, sub *appv1.Subscription) appv1.ClusterOverrides <span class="cov8" title="1">{
        dploverrides := appv1.ClusterOverrides{}

        for _, overrides := range sub.Spec.PackageOverrides </span><span class="cov8" title="1">{
                if overrides.PackageName == packageName </span><span class="cov8" title="1">{
                        klog.Infof("Overrides for package %s found", packageName)
                        dploverrides.ClusterName = packageName
                        dploverrides.ClusterOverrides = make([]appv1.ClusterOverride, 0)

                        for _, override := range overrides.PackageOverrides </span><span class="cov8" title="1">{
                                clusterOverride := appv1.ClusterOverride{
                                        RawExtension: runtime.RawExtension{
                                                Raw: override.RawExtension.Raw,
                                        },
                                }
                                dploverrides.ClusterOverrides = append(dploverrides.ClusterOverrides, clusterOverride)
                        }</span>

                        <span class="cov8" title="1">return dploverrides</span>
                }
        }

        <span class="cov8" title="1">return dploverrides</span>
}

//FilterCharts filters the indexFile by name, version, digest
func FilterCharts(sub *appv1.Subscription, indexFile *repo.IndexFile) error <span class="cov8" title="1">{
        //Removes all entries from the indexFile with non matching name
        err := removeNoMatchingName(sub, indexFile)
        if err != nil </span><span class="cov8" title="1">{
                klog.Warning(err)
        }</span>
        //Removes non matching version, digest
        <span class="cov8" title="1">filterOnVersion(sub, indexFile)
        //Keep only the lastest version if multiple remains after filtering.
        err = takeLatestVersion(indexFile)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to filter on version with error: ", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

//takeLatestVersion if the indexFile contains multiple versions for a given chart, then
//only the latest is kept.
func takeLatestVersion(indexFile *repo.IndexFile) (err error) <span class="cov8" title="1">{
        indexFile.SortEntries()

        for k := range indexFile.Entries </span><span class="cov8" title="1">{
                //Get return the latest version when version is empty but
                //there is a bug in the masterminds semver used by helm
                // "*" constraint is not working properly
                // "*" is equivalent to "&gt;=0.0.0"
                chartVersion, err := indexFile.Get(k, "&gt;=0.0.0")
                if err != nil </span><span class="cov0" title="0">{
                        klog.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">indexFile.Entries[k] = []*repo.ChartVersion{chartVersion}</span>
        }

        <span class="cov8" title="1">return nil</span>
}

//checkDigest Checks if the digest matches
func checkDigest(sub *appv1.Subscription, chartVersion *repo.ChartVersion) bool <span class="cov8" title="1">{
        if sub != nil </span><span class="cov8" title="1">{
                if sub.Spec.PackageFilter != nil </span><span class="cov8" title="1">{
                        if sub.Spec.PackageFilter.Annotations != nil </span><span class="cov0" title="0">{
                                if filterDigest, ok := sub.Spec.PackageFilter.Annotations["digest"]; ok </span><span class="cov0" title="0">{
                                        return filterDigest == chartVersion.Digest
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">klog.V(4).Info("Digest check passed for:", chartVersion)

        return true</span>
}

//removeNoMatchingName Deletes entries that the name doesn't match the name provided in the subscription
func removeNoMatchingName(sub *appv1.Subscription, indexFile *repo.IndexFile) error <span class="cov8" title="1">{
        if sub.Spec.Package != "" </span><span class="cov8" title="1">{
                keys := make([]string, 0)
                for k := range indexFile.Entries </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>

                <span class="cov8" title="1">for _, k := range keys </span><span class="cov8" title="1">{
                        if k != sub.Spec.Package </span><span class="cov8" title="1">{
                                delete(indexFile.Entries, k)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                return fmt.Errorf("subsciption.spec.package is missing for subscription: %s/%s", sub.Namespace, sub.Name)
        }</span>

        <span class="cov8" title="1">klog.V(4).Info("After name matching:", indexFile)

        return nil</span>
}

//filterOnVersion filters the indexFile with the version, and Digest provided in the subscription
//The version provided in the subscription can be an expression like "&gt;=1.2.3" (see https://github.com/Masterminds/semver)
func filterOnVersion(sub *appv1.Subscription, indexFile *repo.IndexFile) <span class="cov8" title="1">{
        keys := make([]string, 0)
        for k := range indexFile.Entries </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>

        <span class="cov8" title="1">for _, k := range keys </span><span class="cov8" title="1">{
                chartVersions := indexFile.Entries[k]
                newChartVersions := make([]*repo.ChartVersion, 0)

                for index, chartVersion := range chartVersions </span><span class="cov8" title="1">{
                        if checkKeywords(sub, chartVersion) &amp;&amp; checkDigest(sub, chartVersion) &amp;&amp; checkVersion(sub, chartVersion) </span><span class="cov8" title="1">{
                                newChartVersions = append(newChartVersions, chartVersions[index])
                        }</span>
                }

                <span class="cov8" title="1">if len(newChartVersions) &gt; 0 </span><span class="cov8" title="1">{
                        indexFile.Entries[k] = newChartVersions
                }</span> else<span class="cov8" title="1"> {
                        delete(indexFile.Entries, k)
                }</span>
        }

        <span class="cov8" title="1">klog.V(4).Info("After version matching:", indexFile)</span>
}

//checkKeywords Checks if the charts has at least 1 keyword from the packageFilter.Keywords array
func checkKeywords(sub *appv1.Subscription, chartVersion *repo.ChartVersion) bool <span class="cov8" title="1">{
        var labelSelector *metav1.LabelSelector
        if sub.Spec.PackageFilter != nil </span><span class="cov8" title="1">{
                labelSelector = sub.Spec.PackageFilter.LabelSelector
        }</span>

        <span class="cov8" title="1">return KeywordsChecker(labelSelector, chartVersion.Keywords)</span>
}

//checkVersion checks if the version matches
func checkVersion(sub *appv1.Subscription, chartVersion *repo.ChartVersion) bool <span class="cov8" title="1">{
        if sub.Spec.PackageFilter != nil </span><span class="cov8" title="1">{
                if sub.Spec.PackageFilter.Version != "" </span><span class="cov8" title="1">{
                        version := chartVersion.Version
                        versionVersion, err := semver.NewVersion(version)

                        if err != nil </span><span class="cov0" title="0">{
                                klog.Error(err)
                                return false
                        }</span>

                        <span class="cov8" title="1">filterVersion, err := semver.NewConstraint(sub.Spec.PackageFilter.Version)

                        if err != nil </span><span class="cov0" title="0">{
                                klog.Error(err)
                                return false
                        }</span>

                        <span class="cov8" title="1">return filterVersion.Check(versionVersion)</span>
                }
        }

        <span class="cov8" title="1">klog.V(4).Info("Version check passed for:", chartVersion)

        return true</span>
}

//DeleteHelmReleaseCRD deletes the HelmRelease CRD
func DeleteHelmReleaseCRD(runtimeClient client.Client, crdx *clientsetx.Clientset) <span class="cov8" title="1">{
        hrlist := &amp;releasev1.HelmReleaseList{}
        err := runtimeClient.List(context.TODO(), hrlist, &amp;client.ListOptions{})

        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                klog.Infof("HelmRelease kind is gone. err: %s", err.Error())
                os.Exit(0)
        }</span> else<span class="cov8" title="1"> {
                for _, hr := range hrlist.Items </span><span class="cov8" title="1">{
                        hr := hr
                        klog.V(1).Infof("Found %s", hr.SelfLink)
                        // remove all finalizers
                        hr = *hr.DeepCopy()
                        hr.SetFinalizers([]string{})
                        err = runtimeClient.Update(context.TODO(), &amp;hr)
                        if err != nil </span><span class="cov0" title="0">{
                                klog.Warning(err)
                        }</span>
                }
                // now get rid of the crd
                <span class="cov8" title="1">err = crdx.ApiextensionsV1().CustomResourceDefinitions().Delete(context.TODO(), "helmreleases.apps.open-cluster-management.io", metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        klog.Infof("Deleting helmrelease CRD failed. err: %s", err.Error())
                }</span> else<span class="cov8" title="1"> {
                        klog.Info("helmrelease CRD removed")
                }</span>
        }
}

//IsURL return true if string is a valid URL
func IsURL(str string) bool <span class="cov8" title="1">{
        u, err := url.Parse(str)
        return err == nil &amp;&amp; u.Scheme != "" &amp;&amp; u.Host != ""
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "io/ioutil"
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/klog/v2"
)

func NamespacedNameFormat(str string) types.NamespacedName <span class="cov8" title="1">{
        nn := types.NamespacedName{}

        if str != "" </span><span class="cov8" title="1">{
                strs := strings.Split(str, "/")
                if len(strs) != 2 </span><span class="cov8" title="1">{
                        errmsg := "Illegal string, want namespace/name, but get " + str
                        klog.Error(errmsg)

                        return nn
                }</span>

                <span class="cov8" title="1">nn.Name = strs[1]
                nn.Namespace = strs[0]</span>
        }

        <span class="cov8" title="1">return nn</span>
}

// ConvertLabels coverts label selector to lables.Selector
func ConvertLabels(labelSelector *metav1.LabelSelector) (labels.Selector, error) <span class="cov8" title="1">{
        if labelSelector != nil </span><span class="cov8" title="1">{
                selector, err := metav1.LabelSelectorAsSelector(labelSelector)

                if err != nil </span><span class="cov0" title="0">{
                        return labels.Nothing(), err
                }</span>

                <span class="cov8" title="1">return selector, nil</span>
        }

        <span class="cov8" title="1">return labels.Everything(), nil</span>
}

func GetComponentNamespace() (string, error) <span class="cov0" title="0">{
        nsBytes, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace")
        if err != nil </span><span class="cov0" title="0">{
                return "open-cluster-management-agent-addon", err
        }</span>

        <span class="cov0" title="0">return string(nsBytes), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2020 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "reflect"
        "strings"

        "github.com/ghodss/yaml"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/klog/v2"
        appv1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1"
        "sigs.k8s.io/kustomize/api/krusty"
        kustomizetypes "sigs.k8s.io/kustomize/api/types"
        "sigs.k8s.io/kustomize/kyaml/filesys"
)

// RunKustomizeBuild runs kustomize build and returns the build output
func RunKustomizeBuild(kustomizeDir string) ([]byte, error) <span class="cov8" title="1">{
        fSys := filesys.MakeFsOnDisk()

        // Allow external plugins when executing Kustomize. This is required to support the policy
        // generator. This builtin plugin loading option is the default value and is recommended
        // for production use-cases.
        pluginConfig := kustomizetypes.MakePluginConfig(
                kustomizetypes.PluginRestrictionsNone,
                kustomizetypes.BploUseStaticallyLinked,
        )
        options := &amp;krusty.Options{
                DoLegacyResourceSort: true,
                PluginConfig:         pluginConfig,
        }

        k := krusty.MakeKustomizer(options)
        mapOut, err := k.Run(fSys, kustomizeDir)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">byteOut, err := mapOut.AsYaml()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return byteOut, nil</span>
}

func CheckPackageOverride(ov *appv1.Overrides) error <span class="cov8" title="1">{
        if ov.PackageOverrides == nil || len(ov.PackageOverrides) &lt; 1 </span><span class="cov8" title="1">{
                return errors.New("no PackageOverride is specified. Skipping to override kustomization")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func VerifyAndOverrideKustomize(packageOverrides []*appv1.Overrides, relativePath, kustomizeDir string) <span class="cov0" title="0">{
        for _, ov := range packageOverrides </span><span class="cov0" title="0">{
                ovKustomizeDir := strings.Split(ov.PackageName, "kustomization")[0]

                //If the full kustomization.yaml path is specified but different than the current kustomize dir, egnore
                if !strings.EqualFold(ovKustomizeDir, relativePath) &amp;&amp; !strings.EqualFold(ovKustomizeDir, "") </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        err := CheckPackageOverride(ov)

                        if err != nil </span><span class="cov0" title="0">{
                                klog.Error("Failed to apply kustomization, error: ", err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                klog.Info("Overriding kustomization ", kustomizeDir)

                                pov := ov.PackageOverrides[0] // there is only one override for kustomization.yaml
                                err := OverrideKustomize(pov, kustomizeDir)

                                if err != nil </span><span class="cov0" title="0">{
                                        klog.Error("Failed to override kustomization.")
                                        break</span>
                                }
                        }
                }
        }
}

func OverrideKustomize(pov appv1.PackageOverride, kustomizeDir string) error <span class="cov8" title="1">{
        kustomizeOverride := appv1.ClusterOverride(pov)
        ovuobj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&amp;kustomizeOverride)

        klog.Info("Kustomize parse : ", ovuobj, "with err:", err, " path: ", ovuobj["path"], " value:", ovuobj["value"])

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Kustomize parse error: ", ovuobj, "with err:", err, " path: ", ovuobj["path"], " value:", ovuobj["value"])
                return err
        }</span>

        <span class="cov8" title="1">if ovuobj["value"] == nil </span><span class="cov0" title="0">{
                klog.Error("Kustomize PackageOverride has no value")
                return nil
        }</span>

        <span class="cov8" title="1">str := fmt.Sprintf("%v", ovuobj["value"])

        var override map[string]interface{}

        if strings.EqualFold(reflect.ValueOf(ovuobj["value"]).Kind().String(), "string") </span><span class="cov8" title="1">{
                if err := yaml.Unmarshal([]byte(str), &amp;override); err != nil </span><span class="cov0" title="0">{
                        klog.Error("Failed to override kustomize with error: ", err)
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                override = ovuobj["value"].(map[string]interface{})
        }</span>

        <span class="cov8" title="1">kustomizeYamlFilePath := filepath.Join(kustomizeDir, "kustomization.yaml")

        if _, err := os.Stat(kustomizeYamlFilePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                kustomizeYamlFilePath = filepath.Join(kustomizeDir, "kustomization.yml")
                if _, err := os.Stat(kustomizeYamlFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        klog.Error("Kustomization file not found in ", kustomizeDir)
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = mergeKustomization(kustomizeYamlFilePath, override)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func mergeKustomization(kustomizeYamlFilePath string, override map[string]interface{}) error <span class="cov8" title="1">{
        var master map[string]interface{}

        bs, err := ioutil.ReadFile(kustomizeYamlFilePath) // #nosec G304 constructed filepath.Join(kustomizeDir, "kustomization.yaml")

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to read file ", kustomizeYamlFilePath, " err: ", err)
                return err
        }</span>

        <span class="cov8" title="1">if err := yaml.Unmarshal(bs, &amp;master); err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to unmarshal kustomize file ", " err: ", err)
                return err
        }</span>

        <span class="cov8" title="1">for k, v := range override </span><span class="cov8" title="1">{
                master[k] = v
        }</span>

        <span class="cov8" title="1">bs, err = yaml.Marshal(master)

        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to marshal kustomize file ", " err: ", err)
                return err
        }</span>

        <span class="cov8" title="1">if err := ioutil.WriteFile(kustomizeYamlFilePath, bs, 0600); err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to overwrite kustomize file ", " err: ", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "fmt"
        "unicode"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/klog/v2"
)

func MatchLabelForSubAndDpl(ls *metav1.LabelSelector, dplls map[string]string) bool <span class="cov8" title="1">{
        klog.V(5).Infof("sub label: %#v, dpl label: %#v", ls, dplls)

        if ls == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(dplls) &lt; 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for k, mv := range ls.MatchLabels </span><span class="cov8" title="1">{
                v, ok := dplls[k]
                if !ok </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">if v != mv </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// to leverage the expression and matcthlabels, we can do the following,
// 1, get a selector from LabelSelector
//                https://github.com/kubernetes/apimachinery/blob/461753078381c979582f217a28eb759ebee5295d/pkg/apis/meta/v1/helpers.go#L34
// this is done at:
// clSelector, err := dplutils.ConvertLabels(s.Subscription.Spec.PackageFilter.LabelSelector)
// func ConvertLabels(labelSelector *metav1.LabelSelector) (labels.Selector, error) {}

// 2, use selector to match up, https://github.com/kubernetes/apimachinery/blob/master/pkg/labels/selector_test.go

func LabelChecker(ls *metav1.LabelSelector, dplls map[string]string) bool <span class="cov8" title="1">{
        clSelector, err := ConvertLabels(ls)
        if err != nil </span><span class="cov0" title="0">{ // which means the subscription's lable selector is not set up correctly
                klog.Infof("Can't process labels due to: %v. In this case, all labels will be rejected", err)
                return false
        }</span>

        <span class="cov8" title="1">return clSelector.Matches(labels.Set(dplls))</span>
}

// ValidateK8sLabel returns a valid k8s label string by enforcing k8s label values rules as below
// 1. Must consist of alphanumeric characters, '-', '_' or '.'
//    No need to check this as the input string is the host name of the k8s api url
// 2. Must be no more than 63 characters
// 3. Must start and end with an alphanumeric character
func ValidateK8sLabel(s string) string <span class="cov8" title="1">{
        // must be no more than 63 characters
        s = fmt.Sprintf("%.63s", s)

        // look for the first alphanumeric byte from the start
        start := 0
        for ; start &lt; len(s); start++ </span><span class="cov8" title="1">{
                c := s[start]
                if unicode.IsLetter(rune(c)) || unicode.IsNumber(rune(c)) </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // Now look for the first alphanumeric byte from the end
        <span class="cov8" title="1">stop := len(s)
        for ; stop &gt; start; stop-- </span><span class="cov8" title="1">{
                c := s[stop-1]
                if unicode.IsLetter(rune(c)) || unicode.IsNumber(rune(c)) </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return s[start:stop]</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "errors"
        "strings"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/klog/v2"

        appsubv1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1"
)

// PrepareOverrides returns the overridemap for given subscription instance.
func PrepareOverrides(cluster types.NamespacedName, appsub *appsubv1.Subscription) ([]appsubv1.ClusterOverride, error) <span class="cov0" title="0">{
        if klog.V(QuiteLogLel).Enabled() </span><span class="cov0" title="0">{
                fnName := GetFnName()
                klog.Infof("Entering: %v()", fnName)

                defer klog.Infof("Exiting: %v()", fnName)
        }</span>

        <span class="cov0" title="0">if appsub == nil || appsub.Spec.Overrides == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var overrides []appsubv1.ClusterOverride

        // go over clsuters to find matching override
        for _, ov := range appsub.Spec.Overrides </span><span class="cov0" title="0">{
                if ov.ClusterName == cluster.Name || (ov.ClusterName == "/" &amp;&amp; cluster.Name != "" &amp;&amp; cluster.Namespace != "") </span><span class="cov0" title="0">{
                        overrides = ov.ClusterOverrides

                        break</span>
                }
        }

        <span class="cov0" title="0">klog.Infof("get overrides: %#v", overrides)

        return overrides, nil</span>
}

// OverrideTemplate alter the given template with overrides.
func OverrideTemplate(template *unstructured.Unstructured, overrides []appsubv1.ClusterOverride) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        if klog.V(QuiteLogLel).Enabled() </span><span class="cov0" title="0">{
                fnName := GetFnName()
                klog.Infof("Entering: %v()", fnName)

                defer klog.Infof("Exiting: %v()", fnName)
        }</span>

        <span class="cov8" title="1">ovt := template.DeepCopy()

        if template == nil || overrides == nil </span><span class="cov8" title="1">{
                klog.Info("No Instance or no override for template")
                return ovt, nil
        }</span>

        <span class="cov8" title="1">for _, override := range overrides </span><span class="cov8" title="1">{
                ovuobj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&amp;override) // #nosec G601 requires "k8s.io/apimachinery/pkg/runtime" object
                klog.V(1).Info("From Instance Converter", ovuobj, "with err:", err, " path: ", ovuobj["path"], " value:", ovuobj["value"])

                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("can not parse override")
                }</span>

                <span class="cov8" title="1">path, ok := ovuobj["path"].(string)

                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("can not convert path of override")
                }</span>

                <span class="cov8" title="1">fields := strings.Split(path, ".")
                err = unstructured.SetNestedField(ovt.Object, ovuobj["value"], fields...)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error("Failed to set nested field for overriding template with error:", err)
                }</span>
        }

        <span class="cov8" title="1">klog.V(1).Info("Finished overriding template:", ovt)

        return ovt, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package utils

import (
        "context"
        "time"

        "k8s.io/apimachinery/pkg/api/errors"
        metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/klog/v2"
        appsubReportV1alpha1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1alpha1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// Create PropagatioFailed result in cluster appsubReport in the managed cluster namespace
func CreateFailedAppsubReportResult(client client.Client, cluster string, appsubNs, appsubName, statusMsg string) error <span class="cov8" title="1">{
        // Get cluster appsub reports
        appsubReport, err := getClusterAppsubReport(client, cluster, true)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Error getting cluster appsubReport:%v/%v, err:%v", appsubReport.Namespace, appsubReport.Name, err)
                return err
        }</span>

        // Update result in appsub report
        <span class="cov8" title="1">prResultFoundIndex := -1
        prResultSource := appsubNs + "/" + appsubName

        for i, result := range appsubReport.Results </span><span class="cov0" title="0">{
                if result.Source == prResultSource </span><span class="cov0" title="0">{
                        prResultFoundIndex = i
                        break</span>
                }
        }

        <span class="cov8" title="1">klog.V(1).Infof("Update appsubReport: %v/%v, resultIndex:%v", appsubReport.Namespace, appsubReport.Name, prResultFoundIndex)

        if prResultFoundIndex &lt; 0 </span><span class="cov8" title="1">{
                // Deploy failed but result not in appsub report - add it
                klog.V(1).Infof("Add result (source:%v) to appsubReport", prResultSource)

                prFailedResult := &amp;appsubReportV1alpha1.SubscriptionReportResult{
                        Source:    prResultSource,
                        Result:    "propagationFailed",
                        Timestamp: metaV1.Timestamp{Seconds: time.Now().Unix()},
                }
                appsubReport.Results = append(appsubReport.Results, prFailedResult)
        }</span>

        <span class="cov8" title="1">if err := client.Update(context.TODO(), appsubReport); err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Error in updating on hub, appsubReport:%v/%v, err:%v", appsubReport.Namespace, appsubReport.Name, err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getClusterAppsubReport(rClient client.Client, clusterAppsubReportNs string,
        create bool) (*appsubReportV1alpha1.SubscriptionReport, error) <span class="cov8" title="1">{
        appsubReport := &amp;appsubReportV1alpha1.SubscriptionReport{
                TypeMeta: metaV1.TypeMeta{
                        Kind:       "SubscriptionReport",
                        APIVersion: "apps.open-cluster-management.io/v1alpha1",
                },
        }
        appsubReport.Namespace = clusterAppsubReportNs
        appsubReport.Name = clusterAppsubReportNs

        klog.V(1).Infof("Get cluster appsubReport: %v/%v", appsubReport.Namespace, appsubReport.Name)

        if err := rClient.Get(context.TODO(),
                client.ObjectKey{Name: appsubReport.Name, Namespace: appsubReport.Namespace}, appsubReport); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        if create </span><span class="cov8" title="1">{
                                klog.V(1).Infof("appsubReport: %v/%v not found, create it.", appsubReport.Namespace, appsubReport.Name)

                                labels := map[string]string{
                                        "apps.open-cluster-management.io/cluster": "true",
                                }
                                appsubReport.Labels = labels
                                appsubReport.ReportType = "Cluster"

                                if err := rClient.Create(context.TODO(), appsubReport); err != nil </span><span class="cov0" title="0">{
                                        klog.Errorf("Error in creating on hub, appsubReport:%v/%v, err:%v", appsubReport.Namespace, appsubReport.Name, err)
                                        return appsubReport, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return appsubReport, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        klog.Errorf("Error getting appsubReport:%v/%v, err:%v", appsubReport.Namespace, appsubReport.Name, err)
                        return appsubReport, err
                }</span>
        }

        <span class="cov8" title="1">return appsubReport, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "context"
        "reflect"

        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/klog/v2"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"

        appv1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1"
)

var SecretKindStr = "Secret"
var ConfigMapKindStr = "ConfigMap"
var SubscriptionGVK = schema.GroupVersionKind{
        Group:   appv1.SchemeGroupVersion.Group,
        Kind:    "Subscription",
        Version: appv1.SchemeGroupVersion.Version}

//SercertReferredMarker is used as a label key to filter out the secert coming from reference
var SercertReferredMarker = "IsReferredBySub-"

type referredObject interface {
        runtime.Object
        metav1.Object
}

//ListAndDeployReferredObject handles the create/update reconciler request
// the idea is, first it will try to get the referred secret from the subscription namespace
// if it can't find it,
////it could be it's a brand new secret request or it's trying to use a differenet one.
//// to address these, we will try to list the sercert within the subscription namespace with the subscription label.
//// if we are seeing these secret, we will delete the label of the reconciled subscription.
///// then we will create a new secret and label it
// if we can find a secret at the subscription namespace, it means there must be some other subscription is
// using it. In this case, we will just add an extra label to it
func ListAndDeployReferredObject(clt client.Client, instance *appv1.Subscription, gvk schema.GroupVersionKind, refObj referredObject) error <span class="cov0" title="0">{
        insName := instance.GetName()
        insNs := instance.GetNamespace()
        uObjList := &amp;unstructured.UnstructuredList{}

        uObjList.SetGroupVersionKind(gvk)

        opts := &amp;client.ListOptions{Namespace: insNs}
        err := clt.List(context.TODO(), uObjList, opts)

        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                klog.Errorf("Failed to list referred objects with error %v ", err)
                return err
        }</span>

        <span class="cov0" title="0">found := false
        referLabel := SercertReferredMarker + insName

        for _, obj := range uObjList.Items </span><span class="cov0" title="0">{
                u := obj.DeepCopy()
                lb := u.GetLabels()

                if len(lb) == 0 </span><span class="cov0" title="0">{
                        lb = make(map[string]string)
                }</span>

                <span class="cov0" title="0">if u.GetName() == refObj.GetName() </span><span class="cov0" title="0">{
                        found = true
                        lb[referLabel] = "true"

                        if !reflect.DeepEqual(u, refObj) </span><span class="cov0" title="0">{
                                urerf := refObj
                                newOwers := addObjectOwnedBySub(u, instance)
                                t := types.UID("")

                                urerf.SetLabels(lb)
                                urerf.SetOwnerReferences(newOwers)
                                urerf.SetNamespace(insNs)
                                urerf.SetResourceVersion("")
                                urerf.SetUID(t)

                                if !isEqualObjectsDataOwnersLabels(u, urerf) </span><span class="cov0" title="0">{
                                        err := clt.Update(context.TODO(), urerf)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">klog.V(1).Info("reference object updated via client ", urerf.GetName())</span>
                                }
                        } else<span class="cov0" title="0"> {
                                u.SetLabels(lb)
                                newOwers := addObjectOwnedBySub(u, instance)
                                u.SetOwnerReferences(newOwers)

                                if !isEqualObjectsDataOwnersLabels(obj.DeepCopy(), u) </span><span class="cov0" title="0">{
                                        err := clt.Update(context.TODO(), u)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">klog.V(1).Info("reference object updated via client ", u.GetName())</span>
                                }
                        }

                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if lb[referLabel] == "true" </span><span class="cov0" title="0">{
                        delete(lb, referLabel)

                        owners := u.GetOwnerReferences()
                        if len(owners) &gt; 1 </span><span class="cov0" title="0">{
                                u.SetLabels(lb)
                                newOwers := deleteSubFromObjectOwnersByName(u, insName)
                                u.SetOwnerReferences(newOwers)

                                err := clt.Update(context.TODO(), u)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                err := clt.Delete(context.TODO(), u)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                lb := refObj.GetLabels()

                if len(lb) == 0 </span><span class="cov0" title="0">{
                        lb = make(map[string]string)
                }</span>

                <span class="cov0" title="0">t := types.UID("")

                lb[referLabel] = "true"
                refObj.SetLabels(lb)
                refObj.SetNamespace(insNs)
                refObj.SetResourceVersion("")
                refObj.SetUID(t)

                newOwers := addObjectOwnedBySub(refObj, instance)

                refObj.SetOwnerReferences(newOwers)
                err := clt.Create(context.TODO(), refObj)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("Got error %v, while creating referred object %v for subscription %v", err, refObj.GetName(), insName)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func DeleteReferredObjects(clt client.Client, rq types.NamespacedName, gvk schema.GroupVersionKind) error <span class="cov0" title="0">{
        selector := &amp;metav1.LabelSelector{MatchLabels: map[string]string{SercertReferredMarker + rq.Name: "true"}}
        ls, _ := metav1.LabelSelectorAsSelector(selector)
        opts := &amp;client.ListOptions{
                Namespace:     rq.Namespace,
                LabelSelector: ls,
        }
        uObjList := &amp;unstructured.UnstructuredList{}

        uObjList.SetGroupVersionKind(gvk)

        err := clt.List(context.TODO(), uObjList, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(uObjList.Items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">referLabel := SercertReferredMarker + rq.Name

        for _, obj := range uObjList.Items </span><span class="cov0" title="0">{
                u := obj.DeepCopy()
                lb := u.GetLabels()

                delete(lb, referLabel)

                owners := obj.GetOwnerReferences()
                if len(owners) == 1 </span><span class="cov0" title="0">{ // leave to the k8s handle it
                        continue</span>
                } else<span class="cov0" title="0"> {
                        u.SetLabels(lb)
                        newOwers := deleteSubFromObjectOwnersByName(u, rq.Name)

                        u.SetOwnerReferences(newOwers)
                        err := clt.Update(context.TODO(), u)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func isObjectOwnedBySub(obj referredObject, subname string) bool <span class="cov8" title="1">{
        owers := obj.GetOwnerReferences()

        if len(owers) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, ower := range owers </span><span class="cov8" title="1">{
                if ower.Name == subname </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func addObjectOwnedBySub(obj referredObject, sub *appv1.Subscription) []metav1.OwnerReference <span class="cov8" title="1">{
        if isObjectOwnedBySub(obj, sub.GetName()) </span><span class="cov0" title="0">{
                return obj.GetOwnerReferences()
        }</span>

        <span class="cov8" title="1">owers := obj.GetOwnerReferences()
        newOwer := metav1.OwnerReference{
                APIVersion: SubscriptionGVK.Version,
                Name:       sub.GetName(),
                Kind:       SubscriptionGVK.Kind,
                UID:        sub.GetUID(),
        }
        owers = append(owers, newOwer)

        return owers</span>
}

func deleteSubFromObjectOwnersByName(obj referredObject, subname string) []metav1.OwnerReference <span class="cov8" title="1">{
        if !isObjectOwnedBySub(obj, subname) </span><span class="cov0" title="0">{
                return obj.GetOwnerReferences()
        }</span>

        <span class="cov8" title="1">owners := obj.GetOwnerReferences()

        if len(owners) == 0 </span><span class="cov0" title="0">{
                return owners
        }</span>

        <span class="cov8" title="1">newOwners := make([]metav1.OwnerReference, 0)

        for _, owner := range owners </span><span class="cov8" title="1">{
                if owner.Name != subname </span><span class="cov8" title="1">{
                        newOwners = append(newOwners, owner)
                }</span>
        }

        <span class="cov8" title="1">return newOwners</span>
}

func isEqualObjectsDataOwnersLabels(existingObject *unstructured.Unstructured, referObject referredObject) bool <span class="cov8" title="1">{
        if !reflect.DeepEqual(existingObject.GetOwnerReferences(), referObject.GetOwnerReferences()) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.GetLabels(), referObject.GetLabels()) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">oldData := existingObject.Object["data"]

        newObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(referObject)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("failed to convert reference object to unstructure ", err)

                return false
        }</span>

        <span class="cov8" title="1">if newData := newObj["data"]; !reflect.DeepEqual(oldData, newData) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "context"
        "crypto/sha1" // #nosec G505 Used only to generate random value to be used to generate hash string
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "reflect"
        "strings"
        "time"

        chnv1 "open-cluster-management.io/multicloud-operators-channel/pkg/apis/apps/v1"

        addonV1alpha1 "open-cluster-management.io/api/addon/v1alpha1"
        clusterapi "open-cluster-management.io/api/cluster/v1beta1"
        manifestWorkV1 "open-cluster-management.io/api/work/v1"
        appv1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1"
        appsubReportV1alpha1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1alpha1"
        managedClusterView "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/view/v1beta1"

        corev1 "k8s.io/api/core/v1"
        clientsetx "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
        "k8s.io/apimachinery/pkg/api/equality"
        kerrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/klog/v2"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
)

const (
        //Max is 52 chars but as helm add behind the scene extension -delete-registrations for some objects
        //The new limit is 31 chars
        maxNameLength = 52 - len("-delete-registrations")
        randomLength  = 5
        //minus 1 because we add a dash
        annotationsSep         = ","
        maxGeneratedNameLength = maxNameLength - randomLength - 1
        // klusterletagentaddon secret token reconcile
        addonServiceAccountName      = "application-manager"
        addonServiceAccountNamespace = "open-cluster-management-agent-addon"
)

// PlacementDecisionPredicateFunctions filters PlacementDecision status decisions update
var PlacementDecisionPredicateFunctions = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                newPd := e.ObjectNew.(*clusterapi.PlacementDecision)
                oldPd := e.ObjectOld.(*clusterapi.PlacementDecision)

                return !reflect.DeepEqual(newPd.Status.Decisions, oldPd.Status.Decisions)
        }</span>,
        CreateFunc: func(e event.CreateEvent) bool <span class="cov0" title="0">{
                return true
        }</span>,

        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                return true
        }</span>,
}

func IsSubscriptionResourceChanged(oSub, nSub *appv1.Subscription) bool <span class="cov0" title="0">{
        if IsSubscriptionBasicChanged(oSub, nSub) </span><span class="cov0" title="0">{
                return true
        }</span>

        // do we care phase change?
        <span class="cov0" title="0">if nSub.Status.Phase == "" || nSub.Status.Phase != oSub.Status.Phase </span><span class="cov0" title="0">{
                klog.V(5).Info("We care phase..", nSub.Status.Phase, " vs ", oSub.Status.Phase)
                return true
        }</span>

        <span class="cov0" title="0">klog.V(5).Info("Something we don't care changed")

        return false</span>
}

var AppSubSummaryPredicateFunc = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                klog.Info("UpdateFunc oldlabels:", e.ObjectOld.GetLabels())
                var clusterLabel string
                _, oldOK := e.ObjectOld.GetLabels()["apps.open-cluster-management.io/cluster"]
                clusterLabel, newOK := e.ObjectNew.GetLabels()["apps.open-cluster-management.io/cluster"]

                if !oldOK || !newOK || clusterLabel == "" </span><span class="cov0" title="0">{
                        klog.V(1).Infof("Not a managed cluster appSubPackageStatus updated, old: %v/%v, new: %v/%v",
                                e.ObjectOld.GetNamespace(), e.ObjectOld.GetName(), e.ObjectNew.GetNamespace(), e.ObjectNew.GetName())
                        return false
                }</span>

                <span class="cov0" title="0">oldAppSubSummary, ok := e.ObjectOld.(*appsubReportV1alpha1.SubscriptionReport)
                if !ok </span><span class="cov0" title="0">{
                        klog.V(1).Infof("Not a valid managed cluster appSubPackageStatus, old: %v/%v", e.ObjectOld.GetNamespace(), e.ObjectOld.GetName())
                        return false
                }</span>

                <span class="cov0" title="0">newAppSubSummary, ok := e.ObjectNew.(*appsubReportV1alpha1.SubscriptionReport)
                if !ok </span><span class="cov0" title="0">{
                        klog.V(1).Infof("Not a valid managed cluster appSubPackageStatus, new: %v/%v", e.ObjectNew.GetNamespace(), e.ObjectNew.GetName())
                        return false
                }</span>

                <span class="cov0" title="0">return !equality.Semantic.DeepEqual(oldAppSubSummary, newAppSubSummary)</span>
        },
        CreateFunc: func(e event.CreateEvent) bool <span class="cov0" title="0">{
                klog.Info("CreateFunc oldlabels:", e.Object.GetLabels())

                var clusterLabel string
                clusterLabel, ok := e.Object.GetLabels()["apps.open-cluster-management.io/cluster"]

                if !ok || clusterLabel == "" </span><span class="cov0" title="0">{
                        klog.V(1).Infof("Not a managed cluster appSubPackageStatus created: %v/%v", e.Object.GetNamespace(), e.Object.GetName())
                        return false
                }</span>

                <span class="cov0" title="0">klog.V(1).Infof("New managed cluster appSubPackageStatus created: %v/%v", e.Object.GetNamespace(), e.Object.GetName())
                return true</span>
        },
        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                klog.Info("DeleteFunc oldlabels:", e.Object.GetLabels())

                var clusterLabel string
                clusterLabel, ok := e.Object.GetLabels()["apps.open-cluster-management.io/cluster"]
                if !ok || clusterLabel == "" </span><span class="cov0" title="0">{
                        klog.V(1).Infof("Not a managed cluster appSubPackageStatus deleted: %v/%v", e.Object.GetNamespace(), e.Object.GetName())
                        return false
                }</span>

                <span class="cov0" title="0">klog.Infof("managed cluster appSubPackageStatus deleted: %v/%v", e.Object.GetNamespace(), e.Object.GetName())
                return true</span>
        },
}

// SubscriptionPredicateFunctions filters status update
var SubscriptionPredicateFunctions = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                subOld := e.ObjectOld.(*appv1.Subscription)
                subNew := e.ObjectNew.(*appv1.Subscription)

                return IsSubscriptionResourceChanged(subOld, subNew)
        }</span>,
}

func IsSubscriptionBasicChanged(o, n *appv1.Subscription) bool <span class="cov8" title="1">{
        fOsub := FilterOutTimeRelatedFields(o)
        fNSub := FilterOutTimeRelatedFields(n)

        // need to process delete with finalizers
        if !reflect.DeepEqual(fOsub.GetFinalizers(), fNSub.GetFinalizers()) </span><span class="cov0" title="0">{
                return true
        }</span>

        // we care label change, pass it down
        <span class="cov8" title="1">if !reflect.DeepEqual(fOsub.GetLabels(), fNSub.GetLabels()) </span><span class="cov0" title="0">{
                return true
        }</span>

        // In hub cluster, these annotations get updated by subscription reconcile
        // so remove them before comparison to avoid triggering another reconciliation.
        <span class="cov8" title="1">oldAnnotations := fOsub.GetAnnotations()
        newAnnotations := fNSub.GetAnnotations()

        if !isEqualAnnotationFiled(oldAnnotations, newAnnotations, appv1.AnnotationDeployables) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if !isEqualAnnotationFiled(oldAnnotations, newAnnotations, appv1.AnnotationTopo) </span><span class="cov0" title="0">{
                return true
        }</span>

        // When user updates the desired Git commit or tag, this annotation is expected to change as well by reconcile.
        <span class="cov8" title="1">if !isEqualAnnotationFiled(oldAnnotations, newAnnotations, appv1.AnnotationGitCommit) </span><span class="cov0" title="0">{
                return true
        }</span>

        // we care annotation change. pass it down
        <span class="cov8" title="1">if !reflect.DeepEqual(oldAnnotations, newAnnotations) </span><span class="cov0" title="0">{
                return true
        }</span>

        // we care spec for sure, we use the generation of 2 object to track the
        // spec version
        //https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource
        <span class="cov8" title="1">if !reflect.DeepEqual(fOsub.Spec, fNSub.Spec) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func isEqualAnnotationFiled(o, n map[string]string, key string) bool <span class="cov8" title="1">{
        oDpl := o[key]
        nDpl := n[key]

        oOut := stringToSet(oDpl, annotationsSep)
        nOut := stringToSet(nDpl, annotationsSep)

        delete(o, key)
        delete(n, key)

        return reflect.DeepEqual(oOut, nOut)
}</span>

func stringToSet(in string, sep string) map[string]struct{} <span class="cov8" title="1">{
        out := map[string]struct{}{}

        for _, w := range strings.Split(in, sep) </span><span class="cov8" title="1">{
                if _, ok := out[w]; !ok </span><span class="cov8" title="1">{
                        out[w] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">return out</span>
}

// the input object shouldn't be changed at all
func FilterOutTimeRelatedFields(in *appv1.Subscription) *appv1.Subscription <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">out := in.DeepCopy()

        anno := out.GetAnnotations()
        if len(anno) == 0 </span><span class="cov0" title="0">{
                anno = map[string]string{}
        }</span>

        //annotation that contains time
        //also remove annotations that are added and updated by the subscription controller
        <span class="cov8" title="1">timeFields := []string{"kubectl.kubernetes.io/last-applied-configuration"}

        if anno[appv1.AnnotationGitTag] == "" &amp;&amp; anno[appv1.AnnotationGitTargetCommit] == "" </span><span class="cov8" title="1">{
                timeFields = append(timeFields, appv1.AnnotationGitCommit)
        }</span>

        <span class="cov8" title="1">for _, f := range timeFields </span><span class="cov8" title="1">{
                delete(anno, f)
        }</span>

        <span class="cov8" title="1">out.SetAnnotations(anno)

        //set managedFields time to empty
        outF := []metav1.ManagedFieldsEntry{}

        out.SetManagedFields(outF)
        // we don't actually care about the status, when create a manifestwork for
        // given subscription

        return out</span>
}

// assuming the message is only storing the window info, following format:
// cluster1:active,cluster2:block
func isSameMessage(aMsg, bMsg string) bool <span class="cov8" title="1">{
        aMap, bMap := stringToMap(aMsg), stringToMap(bMsg)
        if len(aMap) != len(bMap) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for ak, av := range aMap </span><span class="cov8" title="1">{
                if bv, ok := bMap[ak]; !ok || av != bv </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func stringToMap(msg string) map[string]string <span class="cov8" title="1">{
        cunits := strings.Split(msg, ",")
        out := map[string]string{}

        for _, val := range cunits </span><span class="cov8" title="1">{
                u := strings.Split(val, ":")

                if len(u) == 2 </span><span class="cov0" title="0">{
                        out[u[0]] = u[1]
                }</span> else<span class="cov8" title="1"> if len(u) == 1 </span><span class="cov8" title="1">{
                        out[u[0]] = ""
                }</span>
        }

        <span class="cov8" title="1">return out</span>
}

func IsHubRelatedStatusChanged(old, nnew *appv1.SubscriptionStatus) bool <span class="cov0" title="0">{
        if !isAnsibleStatusEqual(old.AnsibleJobsStatus, nnew.AnsibleJobsStatus) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if old.Phase != nnew.Phase || !isSameMessage(old.Message, nnew.Message) </span><span class="cov0" title="0">{
                return true
        }</span>

        //care about the managed subscription status
        <span class="cov0" title="0">if !isEqualSubClusterStatus(old.Statuses, nnew.Statuses) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func isAnsibleStatusEqual(a, b appv1.AnsibleJobsStatus) bool <span class="cov0" title="0">{
        if a.LastPosthookJob != b.LastPosthookJob </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if a.LastPrehookJob != b.LastPrehookJob </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// ChannelPredicateFunctions filters channel spec update
var ChannelPredicateFunctions = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                newChn := e.ObjectNew.(*chnv1.Channel)
                oldChn := e.ObjectOld.(*chnv1.Channel)

                oldAnnotations := oldChn.GetAnnotations()
                newAnnotations := newChn.GetAnnotations()

                if !reflect.DeepEqual(oldAnnotations, newAnnotations) </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">return !reflect.DeepEqual(newChn.Spec, oldChn.Spec)</span>
        },
        CreateFunc: func(e event.CreateEvent) bool <span class="cov0" title="0">{
                return true
        }</span>,

        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                return true
        }</span>,
}

// ServiceAccountPredicateFunctions watches for changes in klusterlet-addon-appmgr service account in open-cluster-management-agent-addon namespace
var ServiceAccountPredicateFunctions = predicate.Funcs{
        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov0" title="0">{
                newSA := e.ObjectNew.(*corev1.ServiceAccount)

                if strings.EqualFold(newSA.Namespace, addonServiceAccountNamespace) &amp;&amp; strings.EqualFold(newSA.Name, addonServiceAccountName) </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">return false</span>
        },
        CreateFunc: func(e event.CreateEvent) bool <span class="cov0" title="0">{
                sa := e.Object.(*corev1.ServiceAccount)

                if strings.EqualFold(sa.Namespace, addonServiceAccountNamespace) &amp;&amp; strings.EqualFold(sa.Name, addonServiceAccountName) </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">return false</span>
        },
        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov0" title="0">{
                sa := e.Object.(*corev1.ServiceAccount)

                if strings.EqualFold(sa.Namespace, addonServiceAccountNamespace) &amp;&amp; strings.EqualFold(sa.Name, addonServiceAccountName) </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">return false</span>
        },
}

// GetHostSubscriptionFromObject extract the namespacedname of subscription hosting the object resource
func GetHostSubscriptionFromObject(obj metav1.Object) *types.NamespacedName <span class="cov8" title="1">{
        if obj == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">objanno := obj.GetAnnotations()
        if objanno == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">sourcestr := objanno[appv1.AnnotationHosting]
        if sourcestr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">parsedstr := strings.Split(sourcestr, "/")
        if len(parsedstr) != 2 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">host := &amp;types.NamespacedName{Name: parsedstr[1], Namespace: parsedstr[0]}

        return host</span>
}

// SetInClusterPackageStatus creates status strcuture and fill status
func SetInClusterPackageStatus(substatus *appv1.SubscriptionStatus, pkgname string, pkgerr error, status interface{}) error <span class="cov0" title="0">{
        newStatus := substatus.DeepCopy()
        if newStatus.Statuses == nil </span><span class="cov0" title="0">{
                newStatus.Statuses = make(map[string]*appv1.SubscriptionPerClusterStatus)
        }</span>

        <span class="cov0" title="0">clst := newStatus.Statuses["/"]
        if clst == nil || clst.SubscriptionPackageStatus == nil </span><span class="cov0" title="0">{
                clst = &amp;appv1.SubscriptionPerClusterStatus{}
                clst.SubscriptionPackageStatus = make(map[string]*appv1.SubscriptionUnitStatus)
        }</span>

        <span class="cov0" title="0">pkgstatus := clst.SubscriptionPackageStatus[pkgname]
        if pkgstatus == nil </span><span class="cov0" title="0">{
                pkgstatus = &amp;appv1.SubscriptionUnitStatus{}
        }</span>

        <span class="cov0" title="0">if pkgerr == nil </span><span class="cov0" title="0">{
                pkgstatus.Phase = appv1.SubscriptionSubscribed
                pkgstatus.Reason = ""
                pkgstatus.Message = ""
        }</span> else<span class="cov0" title="0"> {
                pkgstatus.Phase = appv1.SubscriptionFailed
                pkgstatus.Reason = pkgerr.Error()
        }</span>

        <span class="cov0" title="0">var err error

        pkgstatus.LastUpdateTime = metav1.Now()

        if status != nil </span><span class="cov0" title="0">{
                if pkgstatus.ResourceStatus == nil </span><span class="cov0" title="0">{
                        pkgstatus.ResourceStatus = &amp;runtime.RawExtension{}
                }</span>

                <span class="cov0" title="0">pkgstatus.ResourceStatus.Raw, err = json.Marshal(status)

                if err != nil </span><span class="cov0" title="0">{
                        klog.Info("Failed to mashall status for ", status, " with err:", err)
                }</span>
        } else<span class="cov0" title="0"> {
                pkgstatus.ResourceStatus = nil
        }</span>

        <span class="cov0" title="0">klog.V(1).Infof("Set package status, pkg: %v, pkgstatus: %#v", pkgname, pkgstatus)

        clst.SubscriptionPackageStatus[pkgname] = pkgstatus
        newStatus.Statuses["/"] = clst

        newStatus.LastUpdateTime = metav1.Now()

        if isEmptySubscriptionStatus(newStatus) || !isEqualSubscriptionStatus(substatus, newStatus) </span><span class="cov0" title="0">{
                newStatus.DeepCopyInto(substatus)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func isEmptySubscriptionStatus(a *appv1.SubscriptionStatus) bool <span class="cov8" title="1">{
        if a == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(a.Message) != 0 || len(a.Phase) != 0 || len(a.Reason) != 0 || len(a.Statuses) != 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func IsEqualSubScriptionStatus(o, n *appv1.SubscriptionStatus) bool <span class="cov0" title="0">{
        return isEqualSubscriptionStatus(o, n)
}</span>

func isEqualSubscriptionStatus(a, b *appv1.SubscriptionStatus) bool <span class="cov8" title="1">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if a != nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if a == nil &amp;&amp; b != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if !isSameMessage(a.Message, b.Message) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if a.Phase != b.Phase || a.Reason != b.Reason </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">aMap, bMap := a.Statuses, b.Statuses
        if len(aMap) != len(bMap) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(aMap) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return isEqualSubClusterStatus(aMap, bMap)</span>
}

func isEqualSubClusterStatus(a, b map[string]*appv1.SubscriptionPerClusterStatus) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for k, v := range a </span><span class="cov8" title="1">{
                w, ok := b[k]
                if ok </span><span class="cov8" title="1">{
                        if v == nil &amp;&amp; w == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if v != nil &amp;&amp; w != nil &amp;&amp; isEqualSubPerClusterStatus(v.SubscriptionPackageStatus, w.SubscriptionPackageStatus) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">return false</span>
                }

                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">return true</span>
}

func isEqualSubPerClusterStatus(a, b map[string]*appv1.SubscriptionUnitStatus) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for k, v := range a </span><span class="cov8" title="1">{
                if w, ok := b[k]; !ok || !isEqualSubscriptionUnitStatus(v, w) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func isEqualSubscriptionUnitStatus(a, b *appv1.SubscriptionUnitStatus) bool <span class="cov8" title="1">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if a != nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if a == nil &amp;&amp; b != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if !isSameMessage(a.Message, b.Message) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if a.Phase != b.Phase || a.Reason != b.Reason ||
                !reflect.DeepEqual(a.ResourceStatus, b.ResourceStatus) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func UpdateLastUpdateTime(clt client.Client, instance *appv1.Subscription) <span class="cov0" title="0">{
        curSub := &amp;appv1.Subscription{}
        if err := clt.Get(context.TODO(), types.NamespacedName{Name: instance.GetName(), Namespace: instance.GetNamespace()}, curSub); err != nil </span><span class="cov0" title="0">{
                klog.Warning("Failed to get appsub to update LastUpdateTime", err)
                return
        }</span>

        <span class="cov0" title="0">curSub.Status.LastUpdateTime = metav1.Now()

        if err := clt.Status().Update(context.TODO(), curSub); err != nil </span><span class="cov0" title="0">{
                klog.Warning("Failed to update LastUpdateTime", err)
        }</span>
}

// OverrideResourceBySubscription alter the given template with overrides
func OverrideResourceBySubscription(template *unstructured.Unstructured,
        pkgName string, instance *appv1.Subscription) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        ovs := prepareOverrides(pkgName, instance)

        return OverrideTemplate(template, ovs)
}</span>

func prepareOverrides(pkgName string, instance *appv1.Subscription) []appv1.ClusterOverride <span class="cov0" title="0">{
        if instance == nil || instance.Spec.PackageOverrides == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var overrides []appv1.ClusterOverride

        // go over clsuters to find matching override
        for _, ov := range instance.Spec.PackageOverrides </span><span class="cov0" title="0">{
                if ov.PackageName != pkgName </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, pov := range ov.PackageOverrides </span><span class="cov0" title="0">{
                        overrides = append(overrides, appv1.ClusterOverride(pov))
                }</span>
        }

        <span class="cov0" title="0">return overrides</span>
}

//KeywordsChecker Checks if the helm chart has at least 1 keyword from the packageFilter.Keywords array
func KeywordsChecker(labelSelector *metav1.LabelSelector, ks []string) bool <span class="cov8" title="1">{
        ls := make(map[string]string)
        for _, k := range ks </span><span class="cov8" title="1">{
                ls[k] = "true"
        }</span>

        <span class="cov8" title="1">return LabelsChecker(labelSelector, ls)</span>
}

// LabelsChecker checks labels against a labelSelector
func LabelsChecker(labelSelector *metav1.LabelSelector, ls map[string]string) bool <span class="cov8" title="1">{
        clSelector, err := ConvertLabels(labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Failed to set label selector: ", labelSelector, " err:", err)
        }</span>

        <span class="cov8" title="1">return clSelector.Matches(labels.Set(ls))</span>
}

// GetReleaseName alters the given name in a deterministic way if the length exceed the maximum character
func GetReleaseName(base string) (string, error) <span class="cov8" title="1">{
        if len(base) &gt; maxNameLength </span><span class="cov0" title="0">{
                h := sha1.New() // #nosec G401 Used only to generate random value to be used to generate hash string
                _, err := h.Write([]byte(base))

                if err != nil </span><span class="cov0" title="0">{
                        klog.Error("Failed to generate sha1 hash for: ", base, " error: ", err)
                        return "", err
                }</span>

                <span class="cov0" title="0">sha1Hash := hex.EncodeToString(h.Sum(nil))

                //minus 1 because adding "-"
                base = base[:maxGeneratedNameLength]

                return fmt.Sprintf("%s-%s", base, sha1Hash[:randomLength]), nil</span>
        }

        <span class="cov8" title="1">return base, nil</span>
}

// GetPauseLabel check if the subscription-pause label exists
func GetPauseLabel(instance *appv1.Subscription) bool <span class="cov8" title="1">{
        labels := instance.GetLabels()
        if labels == nil </span><span class="cov8" title="1">{
                labels = make(map[string]string)
        }</span>

        <span class="cov8" title="1">if labels[appv1.LabelSubscriptionPause] != "" &amp;&amp; strings.EqualFold(labels[appv1.LabelSubscriptionPause], "true") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// AllowApplyTemplate check if the template is allowed to apply based on its hosting subscription pause label
// return false if the hosting subscription is paused.
func AllowApplyTemplate(localClient client.Client, template *unstructured.Unstructured) bool <span class="cov0" title="0">{
        // if the template is subscription kind, allow its update
        if strings.EqualFold(template.GetKind(), "Subscription") </span><span class="cov0" title="0">{
                return true
        }</span>

        //if the template is not subscription kind, check if its hosting subscription is paused.
        <span class="cov0" title="0">sub := &amp;appv1.Subscription{}
        subkey := GetHostSubscriptionFromObject(template)

        if subkey == nil </span><span class="cov0" title="0">{
                klog.V(1).Infof("The template does not have hosting subscription. template: %v/%v, annoation: %#v",
                        template.GetNamespace(), template.GetName(), template.GetAnnotations())
                return true
        }</span>

        <span class="cov0" title="0">err := localClient.Get(context.TODO(), *subkey, sub)

        if err != nil </span><span class="cov0" title="0">{
                klog.V(1).Infof("Failed to get subscription object. sub: %v, error: %v", *subkey, err)
                return true
        }</span>

        <span class="cov0" title="0">if GetPauseLabel(sub) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// IsResourceAllowed checks if the resource is on application subscription's allow list. The allow list is used only
// if the subscription is created by subscription-admin user.
func IsResourceAllowed(resource unstructured.Unstructured, allowlist map[string]map[string]string, isAdmin bool) bool <span class="cov0" title="0">{
        // If subscription-admin, honor the allow list
        if isAdmin </span><span class="cov0" title="0">{
                // If allow list is empty, all resources are allowed for deploy
                if len(allowlist) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">return (allowlist[resource.GetAPIVersion()][resource.GetKind()] != "" ||
                        allowlist[resource.GetAPIVersion()]["*"] != "")</span>
        }

        // If not subscription-admin, ignore the allow list and don't allow policy
        <span class="cov0" title="0">return resource.GetAPIVersion() != "policy.open-cluster-management.io/v1"</span>
}

// IsResourceDenied checks if the resource is on application subscription's deny list. The deny list is used only
// if the subscription is created by subscription-admin user.
func IsResourceDenied(resource unstructured.Unstructured, denyList map[string]map[string]string, isAdmin bool) bool <span class="cov0" title="0">{
        // If subscription-admin, honor the deny list
        if isAdmin </span><span class="cov0" title="0">{
                // If deny list is empty, all resources are NOT denied
                if len(denyList) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return (denyList[resource.GetAPIVersion()][resource.GetKind()] != "" ||
                        denyList[resource.GetAPIVersion()]["*"] != "")</span>
        }

        // If not subscription-admin, ignore the deny list
        <span class="cov0" title="0">return false</span>
}

// GetAllowDenyLists returns subscription's allow and deny lists as maps. It returns empty map if there is no list.
func GetAllowDenyLists(subscription appv1.Subscription) (map[string]map[string]string, map[string]map[string]string) <span class="cov0" title="0">{
        allowedGroupResources := make(map[string]map[string]string)

        if subscription.Spec.Allow != nil </span><span class="cov0" title="0">{
                for _, allowGroup := range subscription.Spec.Allow </span><span class="cov0" title="0">{
                        for _, resource := range allowGroup.Kinds </span><span class="cov0" title="0">{
                                klog.Info("allowing to deploy resource " + allowGroup.APIVersion + "/" + resource)

                                if allowedGroupResources[allowGroup.APIVersion] == nil </span><span class="cov0" title="0">{
                                        allowedGroupResources[allowGroup.APIVersion] = make(map[string]string)
                                }</span>

                                <span class="cov0" title="0">allowedGroupResources[allowGroup.APIVersion][resource] = resource</span>
                        }
                }
        }

        <span class="cov0" title="0">deniedGroupResources := make(map[string]map[string]string)

        if subscription.Spec.Deny != nil </span><span class="cov0" title="0">{
                for _, denyGroup := range subscription.Spec.Deny </span><span class="cov0" title="0">{
                        for _, resource := range denyGroup.Kinds </span><span class="cov0" title="0">{
                                klog.Info("denying to deploy resource " + denyGroup.APIVersion + "/" + resource)

                                if deniedGroupResources[denyGroup.APIVersion] == nil </span><span class="cov0" title="0">{
                                        deniedGroupResources[denyGroup.APIVersion] = make(map[string]string)
                                }</span>

                                <span class="cov0" title="0">deniedGroupResources[denyGroup.APIVersion][resource] = resource</span>
                        }
                }
        }

        <span class="cov0" title="0">return allowedGroupResources, deniedGroupResources</span>
}

//DeleteSubscriptionCRD deletes the Subscription CRD
func DeleteSubscriptionCRD(runtimeClient client.Client, crdx *clientsetx.Clientset) <span class="cov8" title="1">{
        sublist := &amp;appv1.SubscriptionList{}
        err := runtimeClient.List(context.TODO(), sublist, &amp;client.ListOptions{})

        if err != nil &amp;&amp; !kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                klog.Infof("subscription kind is gone. err: %s", err.Error())
                os.Exit(0)
        }</span> else<span class="cov8" title="1"> {
                for _, sub := range sublist.Items </span><span class="cov0" title="0">{
                        annotations := sub.GetAnnotations()
                        if !strings.EqualFold(annotations[appv1.AnnotationHosting], "") </span><span class="cov0" title="0">{
                                klog.Infof("Found %s", sub.SelfLink)
                                // remove all finalizers
                                sub = *sub.DeepCopy()
                                sub.SetFinalizers([]string{})
                                err = runtimeClient.Update(context.TODO(), &amp;sub) // #nosec G601 requires "k8s.io/apimachinery/pkg/runtime" object
                                if err != nil </span><span class="cov0" title="0">{
                                        klog.Warning(err)
                                }</span>
                        }
                }

                <span class="cov8" title="1">_, err := crdx.ApiextensionsV1().CustomResourceDefinitions().Get(context.TODO(), "multiclusterhubs.operator.open-cluster-management.io", metav1.GetOptions{})

                if err != nil &amp;&amp; kerrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        klog.Info("This is not ACM hub cluster. Deleting subscription CRD.")
                        // now get rid of the crd.
                        err = crdx.ApiextensionsV1().CustomResourceDefinitions().Delete(context.TODO(), "subscriptions.apps.open-cluster-management.io", metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                klog.Infof("Deleting subscription CRD failed. err: %s", err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                klog.Info("subscription CRD removed")
                        }</span>
                } else<span class="cov0" title="0"> {
                        klog.Info("This is ACM hub cluster. Deleting propagated subscriptions only. Not deleting subscription CRD.")
                        for _, sub := range sublist.Items </span><span class="cov0" title="0">{
                                annotations := sub.GetAnnotations()
                                if !strings.EqualFold(annotations[appv1.AnnotationHosting], "") </span><span class="cov0" title="0">{
                                        klog.Infof("Deleting %s", sub.SelfLink)
                                        err = runtimeClient.Delete(context.TODO(), &amp;sub) // #nosec G601 requires "k8s.io/apimachinery/pkg/runtime" object
                                        if err != nil </span><span class="cov0" title="0">{
                                                klog.Warning(err)
                                        }</span>
                                }
                        }
                }
        }
}

// RemoveSubAnnotations removes RHACM specific annotations from subscription
func RemoveSubAnnotations(obj *unstructured.Unstructured) *unstructured.Unstructured <span class="cov8" title="1">{
        objanno := obj.GetAnnotations()
        if objanno != nil </span><span class="cov8" title="1">{
                delete(objanno, appv1.AnnotationClusterAdmin)
                delete(objanno, appv1.AnnotationHosting)
                delete(objanno, appv1.AnnotationSyncSource)
                delete(objanno, appv1.AnnotationHostingDeployable)
                delete(objanno, appv1.AnnotationChannelType)
        }</span>

        <span class="cov8" title="1">if len(objanno) &gt; 0 </span><span class="cov8" title="1">{
                obj.SetAnnotations(objanno)
        }</span> else<span class="cov8" title="1"> {
                obj.SetAnnotations(nil)
        }</span>

        <span class="cov8" title="1">return obj</span>
}

// RemoveSubOwnerRef removes RHACM specific owner reference from subscription
func RemoveSubOwnerRef(obj *unstructured.Unstructured) *unstructured.Unstructured <span class="cov0" title="0">{
        ownerRefs := obj.GetOwnerReferences()
        newOwnerRefs := []metav1.OwnerReference{}

        for _, ownerRef := range ownerRefs </span><span class="cov0" title="0">{
                if !strings.EqualFold(ownerRef.Kind, "Subscription") </span><span class="cov0" title="0">{
                        newOwnerRefs = append(newOwnerRefs, ownerRef)
                }</span>
        }

        <span class="cov0" title="0">if len(newOwnerRefs) &gt; 0 </span><span class="cov0" title="0">{
                obj.SetOwnerReferences(newOwnerRefs)
        }</span> else<span class="cov0" title="0"> {
                obj.SetOwnerReferences(nil)
        }</span>

        <span class="cov0" title="0">return obj</span>
}

func IsSubscriptionBeDeleted(clt client.Client, subKey types.NamespacedName) bool <span class="cov0" title="0">{
        subIns := &amp;appv1.Subscription{}

        if err := clt.Get(context.TODO(), subKey, subIns); err != nil </span><span class="cov0" title="0">{
                return kerrors.IsNotFound(err)
        }</span>

        <span class="cov0" title="0">return !subIns.GetDeletionTimestamp().IsZero()</span>
}

// IsHub determines the hub cluster by listing multiclusterhubs resource items
func IsHub(config *rest.Config) bool <span class="cov0" title="0">{
        var dl dynamic.ResourceInterface

        multiclusterHubGVR := schema.GroupVersionResource{
                Group:    "operator.open-cluster-management.io",
                Version:  "v1",
                Resource: "multiclusterhubs",
        }

        dynamicClient := dynamic.NewForConfigOrDie(config)

        dl = dynamicClient.Resource(multiclusterHubGVR)

        objlist, err := dl.List(context.TODO(), metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if kerrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        klog.Infof("No multiclusterHub resource found, err: %v", err)
                        return false
                }</span>

                <span class="cov0" title="0">klog.Infof("Listing multiclusterHub resource failed, exit... err: %v", err)
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">if objlist == nil </span><span class="cov0" title="0">{
                klog.Infof("obj list is nil, exit...")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">objCount := len(objlist.Items) //nolint
        klog.Infof("multiclusterHub resource count: %v", objCount)

        return objCount &gt; 0</span>
}

// GetReconcileRate determines reconcile rate based on channel annotations
func GetReconcileRate(chnAnnotations, subAnnotations map[string]string) string <span class="cov8" title="1">{
        rate := "medium"

        // If the channel does not have reconcile-level, default it to medium
        if chnAnnotations[appv1.AnnotationResourceReconcileLevel] == "" </span><span class="cov8" title="1">{
                klog.Info("Setting reconcile-level to default: medium")

                rate = "medium"
        }</span> else<span class="cov8" title="1"> {
                if strings.EqualFold(chnAnnotations[appv1.AnnotationResourceReconcileLevel], "off") </span><span class="cov8" title="1">{
                        rate = "off"
                }</span> else<span class="cov8" title="1"> if strings.EqualFold(chnAnnotations[appv1.AnnotationResourceReconcileLevel], "low") </span><span class="cov8" title="1">{
                        rate = "low"
                }</span> else<span class="cov8" title="1"> if strings.EqualFold(chnAnnotations[appv1.AnnotationResourceReconcileLevel], "medium") </span><span class="cov8" title="1">{
                        rate = "medium"
                }</span> else<span class="cov8" title="1"> if strings.EqualFold(chnAnnotations[appv1.AnnotationResourceReconcileLevel], "high") </span><span class="cov8" title="1">{
                        rate = "high"
                }</span> else<span class="cov8" title="1"> {
                        klog.Info("Channel's reconcile-level has unknown value: ", chnAnnotations[appv1.AnnotationResourceReconcileLevel])
                        klog.Info("Setting it to medium")

                        rate = "medium"
                }</span>
        }

        // Reconcile level can be overridden to be
        <span class="cov8" title="1">if strings.EqualFold(subAnnotations[appv1.AnnotationResourceReconcileLevel], "off") </span><span class="cov8" title="1">{
                klog.Infof("Overriding channel's reconcile rate %s to turn it off", rate)
                rate = "off"
        }</span>

        <span class="cov8" title="1">return rate</span>
}

// GetReconcileInterval determines reconcile loop interval based on reconcileRate setting
func GetReconcileInterval(reconcileRate, chType string) (time.Duration, time.Duration, int) <span class="cov8" title="1">{
        interval := 3 * time.Minute       // reconcile interval
        retryInterval := 90 * time.Second // re-try interval when reconcile fails
        retryCount := 1                   // number of re-tries when reconcile fails

        if strings.EqualFold(reconcileRate, "low") </span><span class="cov8" title="1">{
                klog.Infof("setting auto-reconcile rate to low")

                interval = 1 * time.Hour // every hour
                retryInterval = 3 * time.Minute
                retryCount = 3
        }</span> else<span class="cov8" title="1"> if strings.EqualFold(reconcileRate, "medium") </span><span class="cov8" title="1">{
                klog.Infof("setting auto-reconcile rate to medium")

                interval = 3 * time.Minute // every 3 minutes
                if strings.EqualFold(chType, chnv1.ChannelTypeHelmRepo) </span><span class="cov8" title="1">{
                        interval = 15 * time.Minute
                }</span>
                <span class="cov8" title="1">if strings.EqualFold(chType, chnv1.ChannelTypeObjectBucket) </span><span class="cov0" title="0">{
                        interval = 15 * time.Minute
                }</span>
                <span class="cov8" title="1">retryInterval = 90 * time.Second
                retryCount = 1</span>
        } else<span class="cov8" title="1"> if strings.EqualFold(reconcileRate, "high") </span><span class="cov8" title="1">{
                klog.Infof("setting auto-reconcile rate to high")

                interval = 2 * time.Minute // every 2 minutes
                retryInterval = 60 * time.Second
                retryCount = 1
        }</span>

        <span class="cov8" title="1">return interval, retryInterval, retryCount</span>
}

func SetPartOfLabel(s *appv1.Subscription, rsc *unstructured.Unstructured) <span class="cov8" title="1">{
        rscLbls := AddPartOfLabel(s, rsc.GetLabels())
        if rscLbls != nil </span><span class="cov8" title="1">{
                rsc.SetLabels(rscLbls)
        }</span>
}

func AddPartOfLabel(s *appv1.Subscription, m map[string]string) map[string]string <span class="cov8" title="1">{
        partOfLbl := s.Labels["app.kubernetes.io/part-of"]
        if partOfLbl != "" </span><span class="cov8" title="1">{
                if m == nil </span><span class="cov8" title="1">{
                        m = make(map[string]string)
                }</span>

                <span class="cov8" title="1">m["app.kubernetes.io/part-of"] = partOfLbl</span>
        }

        <span class="cov8" title="1">return m</span>
}

// CompareManifestWork compare two manifestWorks and return true if they are equal.
func CompareManifestWork(oldManifestWork, newManifestWork *manifestWorkV1.ManifestWork) bool <span class="cov0" title="0">{
        if len(oldManifestWork.Spec.Workload.Manifests) != len(newManifestWork.Spec.Workload.Manifests) </span><span class="cov0" title="0">{
                klog.V(1).Infof("oldManifestWork length: %v, newManifestWork length: %v",
                        len(oldManifestWork.Spec.Workload.Manifests), len(newManifestWork.Spec.Workload.Manifests))
                return false
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(oldManifestWork.Spec.Workload.Manifests); i++ </span><span class="cov0" title="0">{
                oldManifest := &amp;unstructured.Unstructured{}
                newManifest := &amp;unstructured.Unstructured{}

                err := json.Unmarshal(oldManifestWork.Spec.Workload.Manifests[i].Raw, oldManifest)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("falied to unmarshal old manifestwork, err: %v", err)
                        return false
                }</span>

                <span class="cov0" title="0">klog.V(1).Infof("=====\n oldManifest: %#v", oldManifest)

                err = json.Unmarshal(newManifestWork.Spec.Workload.Manifests[i].Raw, newManifest)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("falied to unmarshal new manifestwork, err: %v", err)
                        return false
                }</span>

                <span class="cov0" title="0">klog.V(1).Infof("=====\n newManifest: %#v", newManifest)

                if !isSameUnstructured(oldManifest, newManifest) </span><span class="cov0" title="0">{
                        klog.V(1).Infof("old template: %#v, new template: %#v", oldManifest, newManifest)
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// isSameUnstructured compares the two unstructured object.
// The comparison ignores the metadata and status field, and check if the two objects are semantically equal.
func isSameUnstructured(obj1, obj2 *unstructured.Unstructured) bool <span class="cov0" title="0">{
        obj1Copy := obj1.DeepCopy()
        obj2Copy := obj2.DeepCopy()

        // Compare gvk, name, namespace at first
        if obj1Copy.GroupVersionKind() != obj2Copy.GroupVersionKind() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if obj1Copy.GetName() != obj2Copy.GetName() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if obj1Copy.GetNamespace() != obj2Copy.GetNamespace() </span><span class="cov0" title="0">{
                return false
        }</span>

        // Compare label and annotations
        <span class="cov0" title="0">if !equality.Semantic.DeepEqual(obj1Copy.GetLabels(), obj2Copy.GetLabels()) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !equality.Semantic.DeepEqual(obj1Copy.GetAnnotations(), obj2Copy.GetAnnotations()) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Compare semantically after removing metadata and status field
        <span class="cov0" title="0">delete(obj1Copy.Object, "metadata")
        delete(obj2Copy.Object, "metadata")
        delete(obj1Copy.Object, "status")
        delete(obj2Copy.Object, "status")

        return equality.Semantic.DeepEqual(obj1Copy.Object, obj2Copy.Object)</span>
}

// IsHostingAppsub return true if contains hosting annotation
func IsHostingAppsub(appsub *appv1.Subscription) bool <span class="cov0" title="0">{
        if appsub == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">annotations := appsub.GetAnnotations()
        if annotations == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">_, ok := annotations[appv1.AnnotationHosting]

        return ok</span>
}

// ParseAPIVersion return group and version from a given apiVersion string
func ParseAPIVersion(apiVersion string) (string, string) <span class="cov0" title="0">{
        parsedstr := strings.Split(apiVersion, "/")
        if len(parsedstr) == 1 </span><span class="cov0" title="0">{
                return "", parsedstr[0]
        }</span>

        <span class="cov0" title="0">if len(parsedstr) != 2 </span><span class="cov0" title="0">{
                return "", ""
        }</span>

        <span class="cov0" title="0">return parsedstr[0], parsedstr[1]</span>
}

// ParseNamespacedName return namespace and name from a given "namespace/name" string
func ParseNamespacedName(namespacedName string) (string, string) <span class="cov0" title="0">{
        parsedstr := strings.Split(namespacedName, "/")

        if len(parsedstr) != 2 </span><span class="cov0" title="0">{
                klog.Infof("invalid namespacedName: %v", namespacedName)
                return "", ""
        }</span>

        <span class="cov0" title="0">return parsedstr[0], parsedstr[1]</span>
}

// FetchChannelReferences best-effort to return the channel secret and configmap if they exist
func FetchChannelReferences(clt client.Client, chn chnv1.Channel) (sec *corev1.Secret, cm *corev1.ConfigMap) <span class="cov0" title="0">{
        if chn.Spec.SecretRef != nil </span><span class="cov0" title="0">{
                secret := &amp;corev1.Secret{}

                chnseckey := types.NamespacedName{
                        Name:      chn.Spec.SecretRef.Name,
                        Namespace: chn.GetNamespace(),
                }

                if chn.Spec.SecretRef.Namespace != "" </span><span class="cov0" title="0">{
                        chnseckey.Namespace = chn.Spec.SecretRef.Namespace
                }</span>

                <span class="cov0" title="0">if err := clt.Get(context.TODO(), chnseckey, secret); err != nil </span><span class="cov0" title="0">{
                        klog.Warningf("failed to get reference secret from channel err: %v, chnseckey: %v", err, chnseckey)
                }</span> else<span class="cov0" title="0"> {
                        sec = secret
                }</span>
        }

        <span class="cov0" title="0">if chn.Spec.ConfigMapRef != nil </span><span class="cov0" title="0">{
                configMap := &amp;corev1.ConfigMap{}

                chncmkey := types.NamespacedName{
                        Name:      chn.Spec.ConfigMapRef.Name,
                        Namespace: chn.GetNamespace(),
                }

                if chn.Spec.ConfigMapRef.Namespace != "" </span><span class="cov0" title="0">{
                        chncmkey.Namespace = chn.Spec.ConfigMapRef.Namespace
                }</span>

                <span class="cov0" title="0">if err := clt.Get(context.TODO(), chncmkey, configMap); err != nil </span><span class="cov0" title="0">{
                        klog.Warningf("failed to get reference configmap from channel err: %v, chnseckey: %v", err, chncmkey)
                }</span> else<span class="cov0" title="0"> {
                        cm = configMap
                }</span>
        }

        <span class="cov0" title="0">return sec, cm</span>
}

// IsReadyManagedClusterView check if managed cluster view API is ready or not.
func IsReadyManagedClusterView(clReader client.Reader) bool <span class="cov0" title="0">{
        viewList := &amp;managedClusterView.ManagedClusterViewList{}

        listopts := &amp;client.ListOptions{}

        err := clReader.List(context.TODO(), viewList, listopts)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Managed Cluster View API NOT ready: ", err)

                return false
        }</span>

        <span class="cov0" title="0">klog.Info("Managed Cluster View API API is ready")

        return true</span>
}

// IsReadyPlacementDecision check if Placement Decision API is ready or not.
func IsReadyPlacementDecision(clReader client.Reader) bool <span class="cov0" title="0">{
        pdlist := &amp;clusterapi.PlacementDecisionList{}

        listopts := &amp;client.ListOptions{}

        err := clReader.List(context.TODO(), pdlist, listopts)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Placement Decision API NOT ready: ", err)

                return false
        }</span>

        <span class="cov0" title="0">cmalist := &amp;addonV1alpha1.ClusterManagementAddOnList{}

        err = clReader.List(context.TODO(), cmalist, listopts)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error("Cluster Management Addon API NOT ready: ", err)

                return false
        }</span>

        <span class="cov0" title="0">klog.Info("Placement Decision and Cluster Management Addon APIs are ready")

        return true</span>
}

func CreateClusterManagementAddon(clt client.Client) <span class="cov0" title="0">{
        cma := &amp;addonV1alpha1.ClusterManagementAddOn{
                ObjectMeta: metav1.ObjectMeta{
                        Name: "application-manager",
                },
                TypeMeta: metav1.TypeMeta{
                        Kind:       "ClusterManagementAddOn",
                        APIVersion: "addon.open-cluster-management.io/v1alpha1",
                },
                Spec: addonV1alpha1.ClusterManagementAddOnSpec{
                        AddOnMeta: addonV1alpha1.AddOnMeta{
                                Description: "Processes events and other requests to managed resources.",
                                DisplayName: "Application Manager",
                        },
                },
        }

        err := clt.Create(context.TODO(), cma)
        if err != nil </span><span class="cov0" title="0">{
                klog.Error(err.Error())
        }</span>
}

// DetectPlacementDecision - Detect the Placement Decision API every 10 seconds. the controller will be exited when it is ready
// The controller will be auto restarted by the multicluster-operators-application deployment CR later.
//nolint:unparam
func DetectPlacementDecision(ctx context.Context, clReader client.Reader, clt client.Client) <span class="cov0" title="0">{
        if !IsReadyPlacementDecision(clReader) </span><span class="cov0" title="0">{
                go wait.UntilWithContext(ctx, func(ctx context.Context) </span><span class="cov0" title="0">{
                        if IsReadyPlacementDecision(clReader) </span><span class="cov0" title="0">{
                                CreateClusterManagementAddon(clt)

                                os.Exit(1)
                        }</span>
                }, time.Duration(10)*time.Second)
        }
}

func GetClientConfigFromKubeConfig(kubeconfigFile string) (*rest.Config, error) <span class="cov0" title="0">{
        if len(kubeconfigFile) &gt; 0 </span><span class="cov0" title="0">{
                return getClientConfig(kubeconfigFile)
        }</span>

        <span class="cov0" title="0">return nil, errors.New("no kubeconfig file found")</span>
}

func getClientConfig(kubeConfigFile string) (*rest.Config, error) <span class="cov0" title="0">{
        kubeConfigBytes, err := ioutil.ReadFile(filepath.Clean(kubeConfigFile))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">kubeConfig, err := clientcmd.NewClientConfigFromBytes(kubeConfigBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">clientConfig, err := kubeConfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return clientConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2021 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "sort"
        "strings"
        "time"

        "k8s.io/klog/v2"

        appv1alpha1 "open-cluster-management.io/multicloud-operators-subscription/pkg/apis/apps/v1"
)

const (
        //MIDNIGHT define the midnight format
        MIDNIGHT        = "12:00AM"
        originYear      = 0
        originMonth     = 1
        originDay       = 1
        debuglevel      = klog.Level(5)
        totaldaysofweek = 7
)

// IsInWindow returns true if the give time is within a timewindow
func IsInWindow(tw *appv1alpha1.TimeWindow, t time.Time) bool <span class="cov8" title="1">{
        if tw == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return NextStartPoint(tw, t) == 0</span>
}

// NextStatusReconcile generate a duartion for the reconcile to requeue after
func NextStatusReconcile(tw *appv1alpha1.TimeWindow, t time.Time) time.Duration <span class="cov8" title="1">{
        if tw == nil </span><span class="cov8" title="1">{
                return time.Duration(0)
        }</span>

        <span class="cov8" title="1">uniCurTime := UnifyTimeZone(tw, t)

        if len(tw.Daysofweek) == 0 &amp;&amp; len(tw.Hours) == 0 </span><span class="cov8" title="1">{
                return time.Duration(0)
        }</span>

        <span class="cov8" title="1">if IsInWindow(tw, uniCurTime) </span><span class="cov8" title="1">{
                vHr := validateHourRange(tw.Hours, getLoc(tw.Location))
                vdays, _ := validateDaysofweekSlice(tw.Daysofweek)
                rvevHr := reverseRange(vHr, getLoc(tw.Location))

                // If currently not blocked but the time window type is `blocked`, we need to get the next time
                // it should be blocked.
                if tw.WindowType != "" &amp;&amp; (strings.EqualFold(tw.WindowType, "block") || strings.EqualFold(tw.WindowType, "blocked")) </span><span class="cov8" title="1">{
                        return generateNextPoint(vHr, vdays, uniCurTime, false) + 1*time.Minute
                }</span>

                // The window type is active so we need to get the next time it should be blocked.
                <span class="cov8" title="1">return generateNextPoint(rvevHr, vdays, uniCurTime, false) + 1*time.Minute</span>
        }

        <span class="cov8" title="1">return NextStartPoint(tw, uniCurTime) + 1*time.Minute</span>
}

//NextStartPoint will map the container's time to the location time specified by user
// then it will handle the window type as will the hour ange and daysofweek
// for hour range and daysofweek, it will handle as the following
// if hour range is empty and weekday is empty then retrun 0
// if hour range is empty and weekday is not then return nextday durtion(here the window type will be considered again)
func NextStartPoint(tw *appv1alpha1.TimeWindow, t time.Time) time.Duration <span class="cov8" title="1">{
        if tw == nil </span><span class="cov8" title="1">{
                return time.Duration(0)
        }</span>

        // convert current time to the location time defined within the timewindow
        <span class="cov8" title="1">uniCurTime := UnifyTimeZone(tw, t)

        klog.V(debuglevel).Infof("Time window checking at %v", uniCurTime.String())

        // valid hour ranges, meaning the each hour range's start time is earlier than the end time
        // also there's no overlap between 2 ranges
        vHr := validateHourRange(tw.Hours, getLoc(tw.Location))

        rDays, rveDays := validateDaysofweekSlice(tw.Daysofweek)

        if tw.WindowType != "" &amp;&amp; (strings.EqualFold(tw.WindowType, "block") || strings.EqualFold(tw.WindowType, "blocked")) </span><span class="cov8" title="1">{
                // reverse slots, the time slots are applicable only for blocked days of the week.
                // If today is not one of the days specified, just return 0
                rvevHr := reverseRange(vHr, getLoc(tw.Location))
                return generateNextPoint(rvevHr, rveDays, uniCurTime, true)
        }</span>

        // generate the duration for t
        <span class="cov8" title="1">return generateNextPoint(vHr, rDays, uniCurTime, false)</span>
}

// UnifyTimeZone convert a given time to the timewindow time zone, if the time window doesn't sepcifiy a
// time zone, then the running machine's time zone will be used
func UnifyTimeZone(tw *appv1alpha1.TimeWindow, t time.Time) time.Time <span class="cov8" title="1">{
        lptr := getLoc(tw.Location)
        return t.In(lptr)
}</span>

func getLoc(loc string) *time.Location <span class="cov8" title="1">{
        l, err := time.LoadLocation(loc)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Error %v while parsing the location string \"%v\", will UTC as location reference %v ", err, loc, l)
        }</span>

        <span class="cov8" title="1">return l</span>
}

type hourRangesInTime struct {
        start time.Time
        end   time.Time
}

// return will be sorted and marged hour ranges
func validateHourRange(rg []appv1alpha1.HourRange, loc *time.Location) []hourRangesInTime <span class="cov8" title="1">{
        if len(rg) == 0 </span><span class="cov8" title="1">{
                return []hourRangesInTime{}
        }</span>

        <span class="cov8" title="1">h := make([]hourRangesInTime, 0)

        for _, r := range rg </span><span class="cov8" title="1">{
                s, e := parseTimeWithKitchenFormat(r.Start, loc), parseTimeWithKitchenFormat(r.End, loc)
                klog.V(debuglevel).Infof("start time paresed as %v, end time %v", s.Format(time.Kitchen), e.Format(time.Kitchen))

                // Support for specifying range in backwards order makes it difficult to determine is 12:00AM
                // is the start time or the end time. For example, time slot: [12:00PM, 12:00AM] is currently restructured as
                // slot for the morning half of the day, instead of the intention, which is the afternoon to midnight.
                // Need special consideration for 12:00AM - if specified as the end time, it is the end of the day
                if s.Before(e) || isMidnight(e) </span><span class="cov8" title="1">{
                        h = append(h, hourRangesInTime{start: s, end: e})
                }</span> else<span class="cov8" title="1"> {
                        h = append(h, hourRangesInTime{start: e, end: s})
                }</span>
        }

        <span class="cov8" title="1">return mergeHourRanges(h)</span>
}

func validateDaysofweekSlice(wds []string) (runDays, runDays) <span class="cov8" title="1">{
        if len(wds) == 0 </span><span class="cov8" title="1">{
                return runDays{}, runDays{}
        }</span>

        <span class="cov8" title="1">vwds := runDays{}

        weekdayMap := map[string]int{
                "sunday":    0,
                "monday":    1,
                "tuesday":   2,
                "wednesday": 3,
                "thursday":  4,
                "friday":    5,
                "saturday":  6,
        }

        found := make(map[string]bool)

        for _, wd := range wds </span><span class="cov8" title="1">{
                wd = strings.ToLower(wd)

                if v, ok := weekdayMap[wd]; ok </span><span class="cov8" title="1">{
                        if _, ok := found[wd]; !ok </span><span class="cov8" title="1">{
                                vwds = append(vwds, time.Weekday(v))
                                found[wd] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">rwds := make(runDays, 0)

        for k, v := range weekdayMap </span><span class="cov8" title="1">{
                if _, ok := found[k]; !ok </span><span class="cov8" title="1">{
                        rwds = append(rwds, time.Weekday(v))
                }</span>
        }

        <span class="cov8" title="1">return vwds, rwds</span>
}

func parseTimeWithKitchenFormat(tstr string, loc *time.Location) time.Time <span class="cov8" title="1">{
        t, err := time.ParseInLocation(time.Kitchen, tstr, loc)
        if err != nil </span><span class="cov8" title="1">{
                curTime := time.Now().UTC()
                klog.Errorf("can't paser the time %v, err: %v, will use the current time %v instead", tstr, err, curTime.String())

                return curTime
        }</span>

        <span class="cov8" title="1">return t</span>
}

// next time will be:
// if current time is bigger than the last time point of the window, nextTime will be daysofweek offset + the hour offset
// if current time is smaller than the lastSlot time point, nextTime will be a duration till next time
//slot start point or a 0(if current time is within a time window)
func generateNextPoint(slots []hourRangesInTime, rdays runDays, uniCurTime time.Time, blocked bool) time.Duration <span class="cov8" title="1">{
        if len(slots) == 0 &amp;&amp; len(rdays) == 0 </span><span class="cov8" title="1">{
                return time.Duration(0)
        }</span>

        <span class="cov8" title="1">if blocked </span><span class="cov8" title="1">{
                // rdays is the list of week days that are not blocked. If today is one of these days, just return 0
                // to indicate that it is in active window.
                for _, runDay := range rdays </span><span class="cov8" title="1">{
                        if runDay == uniCurTime.Weekday() </span><span class="cov8" title="1">{
                                return time.Duration(0)
                        }</span>
                }

                // current day is blocked, check with current day time slots
                <span class="cov8" title="1">if len(slots) != 0 </span><span class="cov8" title="1">{
                        cdTime := tillNextSlotInCurrentDay(slots, uniCurTime)
                        if cdTime &gt;= 0 </span><span class="cov8" title="1">{
                                return cdTime
                        }</span>
                }

                // Current day is blocked and no active slots today - calculate time to active slot in future day
                <span class="cov8" title="1">nextActiveTime := timeLeftTillNextMidNight(uniCurTime)

                if len(slots) != 0 </span><span class="cov8" title="1">{
                        // only need to check next day - it will either be an active day or have an active time slot
                        nextDay := uniCurTime.Add(time.Hour * 24)
                        if !rdays.isCurDayInDaysOfWeek(nextDay.Weekday()) </span><span class="cov8" title="1">{
                                nextActiveTime += tillNextSlotFromMidnight(slots, uniCurTime)
                        }</span>
                } else<span class="cov0" title="0"> {
                        nextActiveTime += rdays.durationToNextRunableWeekday(slots, uniCurTime)
                }</span>

                <span class="cov8" title="1">return nextActiveTime</span>
        }

        // handle active scheduled time
        <span class="cov8" title="1">if len(slots) == 0 &amp;&amp; len(rdays) != 0 </span><span class="cov8" title="1">{
                if rdays.isCurDayInDaysOfWeek(uniCurTime.Weekday()) </span><span class="cov0" title="0">{
                        klog.Infof("Today is in valid Daysofweek time window. Today: %v, valid Daysofweek: %v\n", uniCurTime.Weekday(), rdays)
                        return time.Duration(0)
                }</span>

                <span class="cov8" title="1">return timeLeftTillNextMidNight(uniCurTime) + rdays.durationToNextRunableWeekday(slots, uniCurTime)</span>
        }

        <span class="cov8" title="1">if len(slots) != 0 &amp;&amp; len(rdays) == 0 </span><span class="cov8" title="1">{
                return tillNextSlot(slots, uniCurTime)
        }</span>

        <span class="cov8" title="1">if !rdays.isCurDayInDaysOfWeek(uniCurTime.Weekday()) </span><span class="cov8" title="1">{
                // the current day is not suppose to be active so find the next available time
                return timeLeftTillNextMidNight(uniCurTime) + tillNextSlotFromMidnight(slots, uniCurTime) + rdays.durationToNextRunableWeekday(slots, uniCurTime)
        }</span>

        <span class="cov8" title="1">if rdays.durationToNextRunableWeekday(slots, uniCurTime) == 0 </span><span class="cov8" title="1">{
                // There is another active window today
                ns := tillNextSlotInCurrentDay(slots, uniCurTime)
                if ns &gt;= 0 </span><span class="cov8" title="1">{
                        return ns
                }</span>
        }

        <span class="cov8" title="1">return timeLeftTillNextMidNight(uniCurTime) + tillNextSlotFromMidnight(slots, uniCurTime) + rdays.durationToNextRunableWeekday(slots, uniCurTime)</span>
}

func timeLeftTillNextMidNight(cur time.Time) time.Duration <span class="cov8" title="1">{
        lastMidnight := parseTimeWithKitchenFormat(MIDNIGHT, cur.Location())
        nextMidngiht := lastMidnight.Add(time.Hour * 24)

        gt := time.Date(originYear, originMonth, originDay, cur.Hour(), cur.Minute(), 0, 0, cur.Location())

        return nextMidngiht.Sub(gt)
}</span>

func tillNextSlotFromMidnight(slots []hourRangesInTime, cur time.Time) time.Duration <span class="cov8" title="1">{
        lastMidnight := parseTimeWithKitchenFormat(MIDNIGHT, cur.Location())
        return tillNextSlot(slots, lastMidnight)
}</span>

func tillNextSlot(slots []hourRangesInTime, cur time.Time) time.Duration <span class="cov8" title="1">{
        lastMidnight := parseTimeWithKitchenFormat(MIDNIGHT, cur.Location())
        gt := time.Date(originYear, originMonth, originDay, cur.Hour(), cur.Minute(), 0, 0, cur.Location())
        // t is greater than todays window
        // eg t is 11pm
        // slots [1, 3 pm]
        lastSlot := slots[len(slots)-1].end

        if lastSlot.Before(gt) </span><span class="cov0" title="0">{
                nxtStart := slots[0].start
                // Hour difference is from curret day to midnight, then midnight to slot[0]
                // Current time to the next day's midnight
                return timeLeftTillNextMidNight(gt) + nxtStart.Sub(lastMidnight)
        }</span>

        <span class="cov8" title="1">for _, slot := range slots </span><span class="cov8" title="1">{
                st, ed := slot.start, slot.end

                if gt.Sub(st) &lt;= 0 </span><span class="cov8" title="1">{
                        return st.Sub(gt)
                }</span> else<span class="cov0" title="0"> if gt.Sub(st) &gt; 0 &amp;&amp; gt.Sub(ed) &lt;= 0 </span><span class="cov0" title="0">{
                        return time.Duration(0)
                }</span>
        }

        <span class="cov0" title="0">return time.Duration(0)</span>
}

func tillNextSlotInCurrentDay(slots []hourRangesInTime, cur time.Time) time.Duration <span class="cov8" title="1">{
        gt := time.Date(originYear, originMonth, originDay, cur.Hour(), cur.Minute(), 0, 0, cur.Location())

        for _, slot := range slots </span><span class="cov8" title="1">{
                klog.Infof("Time slot %v:%v - %v:%v", slot.start.Hour(), slot.start.Minute(), slot.end.Hour(), slot.end.Minute())

                // overlapping time slots are merged and sorted
                if gt.Sub(slot.start) &gt; 0 &amp;&amp; (gt.Sub(slot.end) &lt;= 0 || isMidnight(slot.end)) </span><span class="cov8" title="1">{
                        // not blocked now
                        return time.Duration(0)
                }</span> else<span class="cov8" title="1"> if gt.Sub(slot.start) &lt;= 0 </span><span class="cov8" title="1">{
                        // there is available time slot later in current day
                        return slot.start.Sub(gt)
                }</span>
        }

        // blocked now and no time slots available later in current day
        <span class="cov8" title="1">return time.Duration(-1)</span>
}

func isMidnight(t time.Time) bool <span class="cov8" title="1">{
        b := t.Format(time.Kitchen) == MIDNIGHT

        return b
}</span>

func maxHour(a, b time.Time) time.Time <span class="cov8" title="1">{
        if a.Before(b) </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">return a</span>
}

func mergeHourRanges(in []hourRangesInTime) []hourRangesInTime <span class="cov8" title="1">{
        if len(in) &lt; 2 </span><span class="cov8" title="1">{
                return in
        }</span>

        <span class="cov8" title="1">sort.Slice(in, func(i int, j int) bool </span><span class="cov8" title="1">{ return in[i].start.Before(in[j].start) }</span>)

        <span class="cov8" title="1">out := make([]hourRangesInTime, 0)
        out = append(out, in[0])

        l := 0

        for i := 1; i &lt; len(in); i++ </span><span class="cov8" title="1">{
                ed := out[l].end
                s := in[i].start

                if s.Before(ed) || s.Equal(ed) </span><span class="cov8" title="1">{
                        m := maxHour(ed, in[i].end)
                        out[l].end = m
                }</span> else<span class="cov8" title="1"> {
                        out = append(out, in[i])
                        l++
                }</span>
        }

        <span class="cov8" title="1">return out</span>
}

func isThereGap(st, ed time.Time) bool <span class="cov8" title="1">{
        return ed.Sub(st) != 0
}</span>

func reverseRange(in []hourRangesInTime, loc *time.Location) []hourRangesInTime <span class="cov8" title="1">{
        if len(in) == 0 </span><span class="cov0" title="0">{
                return in
        }</span>

        <span class="cov8" title="1">out := make([]hourRangesInTime, 0)

        lastMidnight := parseTimeWithKitchenFormat(MIDNIGHT, loc)

        sp := lastMidnight

        for _, slot := range in </span><span class="cov8" title="1">{
                if isThereGap(sp, slot.start) </span><span class="cov8" title="1">{
                        out = append(out, hourRangesInTime{start: sp, end: slot.start})
                }</span>

                <span class="cov8" title="1">sp = slot.end</span>
        }

        <span class="cov8" title="1">if isMidnight(sp) </span><span class="cov8" title="1">{ // Handle end time being midnight
                sp = sp.Add(time.Hour * 24)
        }</span>

        <span class="cov8" title="1">nextMidngith := lastMidnight.Add(time.Hour * 24)

        if isThereGap(sp, nextMidngith) </span><span class="cov8" title="1">{
                out = append(out, hourRangesInTime{start: sp, end: nextMidngith})
        }</span>

        <span class="cov8" title="1">return out</span>
}

// thie field is actually int
type runDays []time.Weekday

// type runDays []time.Weekday
func (r runDays) durationToNextRunableWeekday(in []hourRangesInTime, cur time.Time) time.Duration <span class="cov8" title="1">{
        // if daysofweek is sorted, we want the next day with is greater than the t.Weekday
        // the daysofweek is loop such as [3, 4, 5], if t==6, we should return 3 aka 4 days
        // if t == 2 then we should return 1
        curWeekday := cur.Weekday()

        if len(r) == 0 </span><span class="cov8" title="1">{
                // this mean you will wait for less than a day.
                return time.Duration(0)
        }</span>

        <span class="cov8" title="1">sort.Slice(r, func(i, j int) bool </span><span class="cov8" title="1">{ return r[i] &lt; r[j] }</span>)

        <span class="cov8" title="1">var days int

        //if the current weekday is later than the latest weekday in the time window,
        //then we find the days left till first runable weekday
        if curWeekday &gt; r[len(r)-1] </span><span class="cov8" title="1">{
                daysLeftOfThisWeek := totaldaysofweek - int(curWeekday)
                mostRecentWeekday := int(r[0])
                days = daysLeftOfThisWeek + mostRecentWeekday
        }</span> else<span class="cov8" title="1"> {
                for _, d := range r </span><span class="cov8" title="1">{
                        // need to take active time slots into consideration
                        // if past all active time slots today then use the next runnable day
                        if curWeekday == d &amp;&amp; tillNextSlotInCurrentDay(in, cur) &gt;= 0 </span><span class="cov8" title="1">{
                                return time.Duration(0)
                        }</span>

                        <span class="cov8" title="1">if curWeekday &lt; d </span><span class="cov8" title="1">{
                                days = int(d - curWeekday)
                                break</span>
                        } else<span class="cov8" title="1"> {
                                // Same day - past last available time slot, handle wrapping of weekdays
                                days = int(d-curWeekday) + 7
                        }</span>
                }
        }

        <span class="cov8" title="1">return time.Duration(days-1) * time.Hour * 24</span>
}

func (r runDays) isCurDayInDaysOfWeek(curWeekday time.Weekday) bool <span class="cov8" title="1">{
        for _, d := range r </span><span class="cov8" title="1">{
                if curWeekday == d </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
